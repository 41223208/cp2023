var tipuesearch = {"pages": [{'title': 'About', 'text': ' https://github.com/mdecycu/cmsite \n', 'tags': '', 'url': 'About.html'}, {'title': 'w5', 'text': '// 包含標準輸出入程式庫的標頭文件\n// https://blog.csdn.net/weixin_38468077/article/details/101069365\n// http://www.gnuplot.info/demo/\n// https://github.com/sysprog21/rv32emu\n// https://github.com/sysprog21/semu \n// https://docs.google.com/presentation/d/14N0cWG2SnBSqhc2cLF0_2VerB9FF8JN3\n// https://cs61c.org/fa23/\n// https://greenteapress.com/wp/think-python-2e/\n// https://github.com/ecalvadi/c99-examples\n// https://github.com/gouravthakur39/beginners-C-program-examples\n// https://github.com/ergenekonyigit/Numerical-Analysis-Examples\n// https://www.che.ncku.edu.tw/facultyweb/changct/html/teaching/CPPandMATLAB/Past/pdf%20Files/Chap02-Ling.pdf\n// https://gteceducation.com.sg/Brochures/PROGRAMMING/C%20PROGRAMMING%20FULL.pdf\n// https://jsommers.github.io/cbook/cbook.pdf\n// https://jsommers.github.io/cbook/index.html\n// http://student.itee.uq.edu.au/courses/csse2310/CProgrammingNotes.pdf\n// http://cslibrary.stanford.edu/101/EssentialC.pdf\n// https://publications.gbdirect.co.uk/c_book/\n// https://www.fossil-scm.org/fossil-book/doc/2ndEdition/fossilbook.pdf\n// ***** execute on replit \n// cd downloads\n// cc gnuplot_ex1.c -o gnuplot_ex1\n// ./gnuplot_ex1\n#include <stdio.h>\n  \n// 主函式\nint main() {\n    // Start a Gnuplot process using popen\n    FILE *gnuplotPipe = popen("gnuplot -persistent", "w");\n    if (!gnuplotPipe) {\n        fprintf(stderr, "Failed to start Gnuplot.\\n");\n        return 1;\n    }\n  \n    // Use Gnuplot plotting commands, specify font and output as PNG\n    fprintf(gnuplotPipe, "set terminal png font \'default,10\' size 800,400\\n");\n    fprintf(gnuplotPipe, "set output \'./../images/gnuplot_ex1.png\'\\n");\n    fprintf(gnuplotPipe, "plot sin(x)");\n    // Close popen\n    pclose(gnuplotPipe);\n  \n    return 0;\n} \n clear \n cd downloads \n cc gnuplot_ex1.c \n ./a.out \n \n \n', 'tags': '', 'url': 'w5.html'}, {'title': 'w6', 'text': '// https://en.wikipedia.org/wiki/Flag_of_the_Republic_of_China\n// cc roc_flag.c -lgd -lm to link with gd and math library\n// https://www.rapidtables.com/web/color/RGB_Color.html\n// 幾何形狀著色與繪圖練習\n// 以下 gd 繪圖程式嘗試畫出 ROC 國旗, 請根據下列程式內容完成後續的國旗繪圖\n#include <stdio.h>\n#include <gd.h>\n#include <math.h>\n\nvoid draw_roc_flag(gdImagePtr img);\nvoid draw_white_sun(gdImagePtr img, int x, int y, int size, int color);\n\nint main() {\n    // width 3: height 2\n    int width = 1200;\n    int height = (int)(width*2.0 / 3.0);\n\n    gdImagePtr img = gdImageCreateTrueColor(width, height);\n    gdImageAlphaBlending(img, 0);\n\n    draw_roc_flag(img);\n\n    FILE *outputFile = fopen("./../images/roc_flag.png", "wb");\n    if (outputFile == NULL) {\n        fprintf(stderr, "Error opening the output file.\\n");\n        return 1;\n    }\n    gdImagePngEx(img, outputFile, 9);\n    fclose(outputFile);\n    gdImageDestroy(img);\n    return 0;\n}\n\nvoid draw_roc_flag(gdImagePtr img) {\n    int width = gdImageSX(img);\n    int height = gdImageSY(img);\n    int red, white, blue;\n    int center_x = (int)(width/4);\n    int center_y = (int)(height/4);\n    int sun_radius = (int)(width/8);\n    // Colors for the flag\n    red = gdImageColorAllocate(img, 242, 0, 0); // Red color\n    white = gdImageColorAllocate(img, 255, 255, 255); // White stripes\n    blue = gdImageColorAllocate(img, 0, 41, 204); // Blue\n    // red rectangle area\n    gdImageFilledRectangle(img, 0, 0, width, height, red);\n    // blue rectangle area\n    gdImageFilledRectangle(img, 0, 0, (int)(width/2.0), (int)(height/2.0), blue);\n    // 目前僅畫出青天白日的輪廓直線, 請嘗試計算所需的點座標完成國旗繪圖\n    draw_white_sun(img, center_x, center_y, sun_radius, white);\n}\n\nvoid draw_white_sun(gdImagePtr img, int center_x, int center_y, int sun_radius, int color) {\n    float angle = 0;\n    int fromX, fromY;\n    int toX, toY;\n    for (int i=0; i<24; i++){\n        angle += 5*M_PI*2/12;\n        //printf("%.3f", angle);\n        toX = center_x + cos(angle)*sun_radius;\n        toY = center_y + sin(angle)*sun_radius;\n        // 只有 i 為 0 時移動到 toX, toY, 其餘都進行直線繪圖\n        if (i!=0){\n            gdImageLine(img, fromX, fromY, toX, toY, color);\n        }\n        fromX = toX;\n        fromY = toY;\n   }\n} \n \n #include <stdio.h>\n#include <gd.h>\n#include <math.h>\n\nvoid draw_usa_flag(gdImagePtr img);\nvoid draw_star(gdImagePtr img, int x, int y, int size, int color, double rotation_angle);\n\nint main() {\n    int width = 800;\n    int height = (int)(width / 1.9);\n\n    gdImagePtr img = gdImageCreateTrueColor(width, height);\n    gdImageAlphaBlending(img, 0);\n\n    draw_usa_flag(img);\n\n    FILE *outputFile = fopen("./../images/usa_flag.png", "wb");\n    if (outputFile == NULL) {\n        fprintf(stderr, "打开输出文件时出错。\\n");\n        return 1;\n    }\n\n    gdImagePngEx(img, outputFile, 9);\n    fclose(outputFile);\n    gdImageDestroy(img);\n\n    return 0;\n}\n\nvoid draw_usa_flag(gdImagePtr img) {\n    int width = gdImageSX(img);\n    int height = gdImageSY(img);\n    int red, white, blue;\n    // 国旗颜色\n    red = gdImageColorAllocate(img, 178, 34, 52); // 红色条纹\n    white = gdImageColorAllocate(img, 255, 255, 255); // 白色条纹\n    blue = gdImageColorAllocate(img, 60, 59, 110); // 蓝色矩形\n\n    int stripe_height = height / 13;\n    int stripe_width = width;\n    int star_size = (int)(0.0308 * height); // 星星大小\n\n    for (int y = 0; y < height; y += stripe_height) {\n        if (y / stripe_height % 2 == 0) {\n            gdImageFilledRectangle(img, 0, y, stripe_width, y + stripe_height, red);\n        } else {\n            gdImageFilledRectangle(img, 0, y, stripe_width, y + stripe_height, white);\n        }\n    }\n\n    gdImageFilledRectangle(img, 0, 0, width * 2 / 5, stripe_height * 7, blue);\n\n    int star_spacing_x = (int)(0.129 * height); // 横向星星之间的间距\n    int star_spacing_y = (int)(0.054 * height); // 纵向星星之间的间距\n    int star_start_x = (int)(0.125 * height); // 星星的起始X位置\n    int star_start_y = (int)(0.0485 * height); // 星星的起始Y位置\n\n    for (int row = 0; row < 9; row++) {\n        int starsPerRow = (row % 2 == 0) ? 6 : 5;\n\n        // 计算2、4、6和8排星星的偏移量\n        int offset_x = (row % 2 == 0) ? star_spacing_x / -2 : 0;\n\n        for (int star = 0; star < starsPerRow; star++) {\n            int x = star_start_x + star * star_spacing_x + offset_x;\n\n            // 旋转角度（以弧度为单位）\n            double rotation_angle = M_PI / 5; // 忘記多少度的旋转\n\n            int y = star_start_y + row * star_spacing_y;\n            draw_star(img, x, y, star_size, white, rotation_angle);\n        }\n    }\n}\n\nvoid draw_star(gdImagePtr img, int x, int y, int size, int color, double rotation_angle) {\n    gdPoint points[10];\n\n    for (int i = 0; i < 10; i++) {\n        double angle = M_PI / 2 + i * 2 * M_PI / 10 + rotation_angle;\n        int radius = (i % 2 == 0) ? size : size / 2;\n        points[i].x = x + radius * cos(angle);\n        points[i].y = y + radius * sin(angle);\n    }\n\n    // 用指定的颜色填充星星\n    gdImageFilledPolygon(img, points, 10, color);\n} \n \n', 'tags': '', 'url': 'w6.html'}, {'title': 'w7', 'text': '#include <stdio.h>\n#include <gd.h>\n#include <math.h>\n\nvoid draw_chinese_flag(gdImagePtr img);\n\nint main() {\n    int width = 300; // 國旗寬度\n    int height = 200; // 國旗高度\n\n    gdImagePtr im = gdImageCreateTrueColor(width, height);\n    gdImageAlphaBlending(im, 0);\n\n    draw_chinese_flag(im);\n\n    FILE *outputFile = fopen("./../images/proc_flag.png", "wb");\n    if (outputFile == NULL) {\n        fprintf(stderr, "打开输出文件时出错。\\n");\n        return 1;\n    }\n\n    gdImagePngEx(im, outputFile, 9);\n    fclose(outputFile);\n    gdImageDestroy(im);\n\n    return 0;\n}\n\n// 声明 draw_star 函数\nvoid draw_star(gdImagePtr img, int x, int y, int size, int color, double rotation_angle);\n\nvoid draw_chinese_flag(gdImagePtr img) {\n    int width = gdImageSX(img);\n    int height = gdImageSY(img);\n    int red, yellow;\n\n    // 國旗顏色\n    red = gdImageColorAllocate(img, 255, 0, 0); // 紅色背景\n    yellow = gdImageColorAllocate(img, 255, 255, 0); // 黃色星星\n\n    // 畫紅色背景\n    gdImageFilledRectangle(img, 0, 0, width, height, red);\n\n    // 設置星星的大小和位置\n    int star_size = (int)(0.28 * height);\n    int star_x = (int)(0.165 * width);\n    int star_y = (int)(0.265 * height);\n\n    // 畫大星星\n    draw_star(img, star_x, star_y, star_size, yellow, 11.0);\n\n    // 繪製小星星，位置根據實際國旗比例計算\n    double radius = 0.15 * height;\n    double angle = 360 / 7 * M_PI / 179.0;\n    double rotation = -M_PI / 7.5;\n    int cx = (int)(0.32 * width);\n    int cy = (int)(0.27 * height);\n\n    for (int i = -1; i < 3; i++) {\n        int x = (int)(cx + radius * cos(i * angle + rotation));\n        int y = (int)(cy + radius * sin(i * angle + rotation));\n        draw_star(img, x, y, 19, yellow, M_PI / 5.0);\n    }\n}\n\nvoid draw_star(gdImagePtr img, int x, int y, int size, int color, double rotation_angle) {\n    gdPoint points[10];\n\n    // 计算星形的五个外点和五个内点\n    double outer_radius = size / 2;\n    double inner_radius = size / 6;\n    double angle = M_PI / 5.0;\n\n    for (int i = 0; i < 10; i++) {\n        double radius = (i % 2 == 0) ? outer_radius : inner_radius;\n        double theta = rotation_angle + i * angle;\n        points[i].x = x + radius * cos(theta);\n        points[i].y = y + radius * sin(theta);\n    }\n\n    // 使用 gdImageFilledPolygon 绘制星形\n    gdImageFilledPolygon(img, points, 10, color);\n} \n \n #include <stdio.h>\n#include <gd.h>\n#include <math.h>\n\nvoid draw_japan_flag(gdImagePtr img);\nvoid draw_white_sun(gdImagePtr img, int center_x, int center_y, int sun_radius, int white, int red );\n\nint main() {\n    // width 3: height 2\n    int width = 1200;\n    int height = 2 * width / 3;\n\n    gdImagePtr img = gdImageCreateTrueColor(width, height);\n    gdImageAlphaBlending(img, 0);\n\n    draw_japan_flag(img);\n\n    FILE *outputFile = fopen("./../images/japan_flag.png", "wb");\n    if (outputFile == NULL) {\n        fprintf(stderr, "Error opening the output file.\\n");\n        return 1;\n    }\n    gdImagePngEx(img, outputFile, 9);\n    fclose(outputFile);\n    gdImageDestroy(img);\n    return 0;\n}\n\nvoid draw_japan_flag(gdImagePtr img) {\n    int width = gdImageSX(img);\n    int height = gdImageSY(img);\n    int red, white ;\n    int center_x =  0.5 * width;\n    int center_y =  0.5 * height;\n    int sun_radius = 145 ;\n\n    // Colors for the flag\n    red = gdImageColorAllocate(img, 242, 0, 0); // Red color\n    white = gdImageColorAllocate(img, 255, 255, 255); // White stripes\n\n\n    // 繪製白色矩形區域\n    gdImageFilledRectangle(img, 0, 0, width, height, white);\n\n\n    // 繪製太陽內部\n    gdImageFilledEllipse(img, center_x, center_y, sun_radius * 3, sun_radius * 3, red);\n} \n \n #include <stdio.h>\n#include <gd.h>\n#include <math.h>\n\nvoid draw_uk_flag(gdImagePtr img);\nvoid fillTriangle(gdImagePtr img, int x1, int y1, int x2, int y2, int x3, int y3, int color);\n\nint main() {\n    // 设置国旗的宽和高\n    int width = 1200;\n    int height = width / 2;\n\n    // 创建图像\n    gdImagePtr img = gdImageCreateTrueColor(width, height);\n    gdImageAlphaBlending(img, 0);\n\n    // 绘制英国国旗\n    draw_uk_flag(img);\n\n    // 将图像保存到文件\n    FILE *outputFile = fopen("./../images/uk_flag.png", "wb");\n    if (outputFile == NULL) {\n        fprintf(stderr, "打开输出文件时发生错误。\\n");\n        return 1;\n    }\n    gdImagePngEx(img, outputFile, 9);\n    fclose(outputFile);\n    gdImageDestroy(img);\n    return 0;\n}\n\n\n\nvoid draw_uk_flag(gdImagePtr img) {\n    int width = gdImageSX(img);\n    int height = gdImageSY(img);\n\n    int red, white, blue;\n    red = gdImageColorAllocate(img, 204, 0, 0);       // 红色\n    white = gdImageColorAllocate(img, 255, 255, 255); // 白色\n    blue = gdImageColorAllocate(img, 0, 0, 153);      // 蓝色\n\n    gdImageFilledRectangle(img, 0, 0, width, height, blue);\n\n\n  int x1, y1, x2, y2, x3, y3;\n  {\n    int line_thickness = 100;\n    gdImageSetThickness(img, line_thickness);\n\n    int x1, y1, x2, y2, x3, y3;\n\n    // 绘制白色斜线\n    x1 = 0;\n    y1 = 600;\n    x2 = 1200;\n    y2 = 0;\n    gdImageLine(img, x1, y1, x2, y2, white);\n\n    x1 = 0;\n    y1 = 0;\n    x2 = 1200;\n    y2 = 600;\n    gdImageLine(img, x1, y1, x2, y2, white);\n}\n  {\n    int line_thickness = 33;\n    gdImageSetThickness(img, line_thickness);\n\n\n    // 绘制红色斜线\n    x1 = 566;\n    y1 = 300;\n    x2 = 1166;\n    y2 = 0;\n    gdImageLine(img, x1, y1, x2, y2, red);\n\n    x1 = 1233;\n    y1 = 600;\n    x2 = 633;\n    y2 = 300;\n    gdImageLine(img, x1, y1, x2, y2, red);\n\n    x1 = 566;\n    y1 = 300;\n    x2 = -33;\n    y2 = 0;\n    gdImageLine(img, x1, y1, x2, y2, red);\n\n    x1 = 600;\n    y1 = 316.5;\n    x2 = 0;\n    y2 = 616.5;\n    gdImageLine(img, x1, y1, x2, y2, red);\n  }\n  {\n  int line_thickness = 33;\n  gdImageSetThickness(img, line_thickness);\n\n  int x1, y1, x2, y2, x3, y3;\n\n  // 绘制  斜线\n  x1 = 0;\n  y1 = 600;\n  x2 = 1200;\n  y2 = 0;\n  gdImageLine(img, x1, y1, x2, y2, red );\n\n\n  x1 = 1200;\n    y1 = 16.5;\n    x2 = 600;\n    y2 = 316.5;\n    gdImageLine(img, x1, y1, x2, y2, white);\n\n\n  x1 = 0;\n    y1 = 583.5;\n    x2 = 600;\n    y2 = 283.5;\n    gdImageLine(img, x1, y1, x2, y2, white);\n\n\n  }\n\n    // 绘制白色十字\n    int cross_width = width / 32;\n    int cross_arm_width = width / 32;\n    int center_x = width / 2;\n    int center_y = height / 2;\n\n    gdImageFilledRectangle(img, center_x + 2.7 * cross_width, 0, center_x - 2.7 * cross_width, height, white);\n    gdImageFilledRectangle(img, 0, center_y + 2.7 * cross_arm_width, width, center_y - 2.7 * cross_arm_width, white);\n\n    // 绘制红色十字\n    gdImageFilledRectangle(img, center_x + 1.5 * cross_width, 0, center_x - 1.5 * cross_width, height, red);\n    gdImageFilledRectangle(img, 0, center_y + 1.5 * cross_arm_width, width, center_y - 1.5 * cross_arm_width, red);\n}  \n \n \n #include <stdio.h>\n#include <gd.h>\n#include <math.h>\n\n#define WIDTH 900\n#define HEIGHT 600\n#define FILENAME "south_korea_flag.png"\n\nint main() {\n    gdImagePtr im;\n    FILE *pngout;\n    int white, black, red, blue;\n\n    im = gdImageCreate(WIDTH, HEIGHT);\n\n    white = gdImageColorAllocate(im, 255, 255, 255);\n    black = gdImageColorAllocate(im, 0, 0, 0);\n    red = gdImageColorAllocate(im, 205, 0, 0);\n    blue = gdImageColorAllocate(im, 0, 56, 168);\n\n    // Background (white)\n    gdImageFilledRectangle(im, 0, 0, WIDTH, HEIGHT , white);\n\n    // Blue Circle (Yin-Yang Symbol)\n    gdImageFilledArc(im, WIDTH / 2, HEIGHT / 2, WIDTH / 3, HEIGHT / 2, 210, 30, red, gdArc);\n\n    // Red Circle (Yin-Yang Symbol)\n    gdImageFilledArc(im, WIDTH / 2, HEIGHT / 2, WIDTH / 3, HEIGHT / 2, 30, 210, blue, gdArc);\n\n  int circleX = 385;    // 圓心的 X 座標\n  int circleY = 262.5;   // 圓心的 Y 座標\n  int circleRadius = 75;     \n\n  // 繪製圓形\n  gdImageFilledEllipse(im, circleX, circleY, circleRadius * 2, circleRadius * 2, red);\n\n  int circleX2 = 515;    // 圓心的 X 座標\n\n int circleY2 = 337.5;\n\n  // 繪製圓形\n  gdImageFilledEllipse(im, circleX2, circleY2, circleRadius * 2, circleRadius * 2, blue);\n\n  {\n\n\n  // 起點和終點位置\n\n  int startX = 340;    \n  // 線的起點 X 座標\n\n  int startY = 90;   \n  // 線的起點 Y 座標\n\n  int endX = 200;     \n  // 線的終點 X 座標\n\n  int endY = 260;     \n  // 線的終點 Y 座標\n\n  int lineWidth = 23;  // 線的寬度\n\n  // 繪製線段\n  gdImageSetThickness(im, lineWidth);\n  gdImageLine(im, startX, startY, endX, endY, black);\n  // 繪製線段\n  gdImageSetThickness(im, lineWidth);\n  gdImageLine(im, startX -35, startY -10, endX -35, endY -10, black);\n\n  // 繪製線段\n  gdImageSetThickness(im, lineWidth);\n  gdImageLine(im, startX -70, startY -20, endX -70, endY -20, black);\n\n  int startX2 = 213;    \n  // 線的起點 X 座標\n\n  int startY2 = 270;   \n  // 線的起點 Y 座標\n\n  int endX2 = 133;     \n  // 線的終點 X 座標\n\n  int endY2 = 210;     \n  // 線的終點 Y 座標\n\n  int lineWidth2 = 25;  // 線的寬度\n\n  // 繪製線段\n  gdImageSetThickness(im, lineWidth);\n  gdImageLine(im, startX2 +3, startY2, endX2 +3, endY2, white);\n\n  gdImageSetThickness(im, lineWidth +10);\ngdImageLine(im, startX2 -17, startY2 +9 , endX2 -17, endY2 +9 , white);\n\n  gdImageSetThickness(im, lineWidth );\ngdImageLine(im, startX2 +115, startY2 -145, endX2 +115, endY2 -145, white);\n\n  gdImageSetThickness(im, lineWidth);\ngdImageLine(im, startX2 +120, startY2 -155, endX2 +120, endY2 -155, white);\n\n  gdImageSetThickness(im, lineWidth +12);\ngdImageLine(im, startX2 +145, startY2 -155, endX2 +145, endY2 -155, white);\n}\n  {\n    // 起點和終點位置\n\n  int startX = 330;    \n  // 線的起點 X 座標\n\n  int startY = 520;   \n  // 線的起點 Y 座標\n\n  int endX = 190;     \n  // 線的終點 X 座標\n\n  int endY = 350;     \n  // 線的終點 Y 座標\n\n  int lineWidth = 23;  // 線的寬度\n\n  // 繪製線段\n  gdImageSetThickness(im, lineWidth);\n  gdImageLine(im, startX, startY, endX, endY, black);\n  // 繪製線段\n  gdImageSetThickness(im, lineWidth);\n  gdImageLine(im, startX -35, startY +10, endX -35, endY +10, black);\n\n  // 繪製線段\n  gdImageSetThickness(im, lineWidth);\n  gdImageLine(im, startX -70, startY +20, endX -70, endY +20, black);\n\n  int startX2 = 213;    \n  // 線的起點 X 座標\n\n  int startY2 = 330;   \n  // 線的起點 Y 座標\n\n  int endX2 = 133;     \n  // 線的終點 X 座標\n\n  int endY2 = 390;     \n  // 線的終點 Y 座標\n\n  int lineWidth2 = 25;  // 線的寬度\n\n  // 繪製線段\n  gdImageSetThickness(im, lineWidth +8);\n  gdImageLine(im, startX2 -11, startY2, endX2 -11, endY2, white);\n\n  gdImageSetThickness(im, lineWidth +10);\ngdImageLine(im, startX2 -30, startY2 -9 , endX2 -30, endY2 -9 , white);\n\n  gdImageSetThickness(im, lineWidth );\ngdImageLine(im, startX2 +100, startY2 +150, endX2 +100, endY2 +150, white);\n\n  gdImageSetThickness(im, lineWidth);\ngdImageLine(im, startX2 +120, startY2 +155, endX2 +120, endY2 +155, white);\n\n  gdImageSetThickness(im, lineWidth +14);\ngdImageLine(im, startX2 +145, startY2 +157, endX2 +145, endY2 +157, white);\n\n    gdImageSetThickness(im, lineWidth -10);\ngdImageLine(im, 232, 426, 206, 448, white);\n\n  }\n\n  {\n    // 起點和終點位置\n\n  int startX = 564;    \n  // 線的起點 X 座標\n\n  int startY = 520;   \n  // 線的起點 Y 座標\n\n  int endX = 704;     \n  // 線的終點 X 座標\n\n  int endY = 350;     \n  // 線的終點 Y 座標\n\n  int lineWidth = 23;  // 線的寬度\n\n  // 繪製線段\n  gdImageSetThickness(im, lineWidth);\n  gdImageLine(im, startX +70, startY +20, endX +70, endY +20, black);\n\n    // 繪製線段\n  gdImageSetThickness(im, lineWidth);\n  gdImageLine(im, startX, startY, endX, endY, black);\n\n    // 繪製線段\n  gdImageSetThickness(im, lineWidth);\n  gdImageLine(im, startX +35, startY +10, endX +35, endY +10, black);\n\ngdImageSetThickness(im, lineWidth -10);\ngdImageLine(im, 624, 400, 734, 490, white);\n\n  int startX2 = 553;    \n  // 線的起點 X 座標\n\n  int startY2 = 330;   \n  // 線的起點 Y 座標\n\n  int endX2 = 633;     \n  // 線的終點 X 座標\n\n  int endY2 = 390;     \n  // 線的終點 Y 座標\n\n  int lineWidth2 = 25;  // 線的寬度\n\n  // 繪製線段\n  gdImageSetThickness(im, lineWidth +8);\n  gdImageLine(im, startX2 +139, startY2, endX2 +139, endY2, white);\n\n  gdImageSetThickness(im, lineWidth +10);\ngdImageLine(im, startX2 +157, startY2 -9 , endX2 +157, endY2 -9 , white);\n\n  gdImageSetThickness(im, lineWidth);\ngdImageLine(im, startX2 +25, startY2 +155, endX2 +25, endY2 +155, white);\n\n  gdImageSetThickness(im, lineWidth +30);\ngdImageLine(im, startX2 -3, startY2 +170, endX2 , endY2 +170, white);\n  }\n  {\n    // 起點和終點位置\n\n  int startX = 330;    \n  // 線的起點 X 座標\n\n  int startY = 520;   \n  // 線的起點 Y 座標\n\n  int endX = 190;     \n  // 線的終點 X 座標\n\n  int endY = 350;     \n  // 線的終點 Y 座標\n\n  int lineWidth = 23;  // 線的寬度\n\n  // 繪製線段\n  gdImageSetThickness(im, lineWidth);\n  gdImageLine(im, startX, startY, endX, endY, black);\n  // 繪製線段\n  gdImageSetThickness(im, lineWidth);\n  gdImageLine(im, startX -35, startY +10, endX -35, endY +10, black);\n\n  // 繪製線段\n  gdImageSetThickness(im, lineWidth);\n  gdImageLine(im, startX -70, startY +20, endX -70, endY +20, black);\n\n  int startX2 = 213;    \n  // 線的起點 X 座標\n\n  int startY2 = 330;   \n  // 線的起點 Y 座標\n\n  int endX2 = 133;     \n  // 線的終點 X 座標\n\n  int endY2 = 390;     \n  // 線的終點 Y 座標\n\n  int lineWidth2 = 25;  // 線的寬度\n\n  // 繪製線段\n  gdImageSetThickness(im, lineWidth +8);\n  gdImageLine(im, startX2 -11, startY2, endX2 -11, endY2, white);\n\n  gdImageSetThickness(im, lineWidth +10);\ngdImageLine(im, startX2 -30, startY2 -9 , endX2 -30, endY2 -9 , white);\n\n  gdImageSetThickness(im, lineWidth );\ngdImageLine(im, startX2 +100, startY2 +150, endX2 +100, endY2 +150, white);\n\n  gdImageSetThickness(im, lineWidth);\ngdImageLine(im, startX2 +120, startY2 +155, endX2 +120, endY2 +155, white);\n\n  gdImageSetThickness(im, lineWidth +14);\ngdImageLine(im, startX2 +145, startY2 +157, endX2 +145, endY2 +157, white);\n\n    gdImageSetThickness(im, lineWidth -10);\ngdImageLine(im, 232, 426, 206, 448, white);\n\n  }\n  {\n    // 起點和終點位置\n\n  int startX = 564;    \n  // 線的起點 X 座標\n\n  int startY = 97;   \n  // 線的起點 Y 座標\n\n  int endX = 704;     \n  // 線的終點 X 座標\n\n  int endY = 267;     \n  // 線的終點 Y 座標\n\n  int lineWidth = 23;  // 線的寬度\n\n  // 繪製線段\n  gdImageSetThickness(im, lineWidth);\n  gdImageLine(im, startX +70, startY -20, endX +70, endY -20, black);\n\n    // 繪製線段\n  gdImageSetThickness(im, lineWidth);\n  gdImageLine(im, startX, startY, endX, endY, black);\n\n    gdImageSetThickness(im, lineWidth -10);\ngdImageLine(im, 624, 212, 734, 118, white);\n\n    // 繪製線段\n  gdImageSetThickness(im, lineWidth);\n  gdImageLine(im, startX +35, startY -10, endX +35, endY -10, black);\n\n  int startX2 = 553;    \n  // 線的起點 X 座標\n\n  int startY2 = 277;   \n  // 線的起點 Y 座標\n\n  int endX2 = 633;     \n  // 線的終點 X 座標\n\n  int endY2 = 217;     \n  // 線的終點 Y 座標\n\n  int lineWidth2 = 25;  // 線的寬度\n\n  // 繪製線段\n  gdImageSetThickness(im, lineWidth +8);\n  gdImageLine(im, startX2 +134, startY2, endX2 +134, endY2, white);\n\n  gdImageSetThickness(im, lineWidth +10);\ngdImageLine(im, startX2 +157, startY2 +9 , endX2 +157, endY2 +9 , white);\n\n  gdImageSetThickness(im, lineWidth);\ngdImageLine(im, startX2 +25, startY2 -155, endX2 +25, endY2 -155, white);\n\n    gdImageSetThickness(im, lineWidth +30);\ngdImageLine(im, startX2 -5, startY2 -155, endX2 -5, endY2 -155, white);\n\n  }\n\n    // Save image\nFILE *outputFile = fopen("./../images/korea_flag.png", "wb");\nif (outputFile == NULL) {\n    fprintf(stderr, "Error opening the output file.\\n");\n    return 1;\n}\n  gdImagePngEx(im, outputFile, 9);\n      fclose(outputFile);\n      gdImageDestroy(im);\n      return 0;\n  } \n \n \n \n \n \n', 'tags': '', 'url': 'w7.html'}, {'title': 'ANSIC', 'text': '練習1 \n 1.輸入數字判斷高於平均身高或低於平均身高或處於平均 \n #include <stdio.h>   // 包含標準輸入/輸出頭文件。\n\nvoid main()\n{\n    float PerHeight;   // 宣告一個浮點數變數 \'PerHeight\' 來儲存人的身高。\n\n    printf("輸入人的身高（以厘米為單位）：");   // 提示用戶輸入身高（以厘米為單位）。\n    scanf("%f", &PerHeight);   // 讀取並將用戶的輸入存儲在 \'PerHeight\' 中。\n\n    if (PerHeight < 150.0)   // 檢查 \'PerHeight\' 是否小於 150.0。\n        printf("這個人是矮子。\\n");   // 印出一條消息，指示這個人是矮子。\n    else if ((PerHeight >= 150.0) && (PerHeight < 165.0))   // 檢查 \'PerHeight\' 是否介於 150.0 和 165.0 之間。\n        printf("這個人身高屬於平均水平。\\n");   // 印出一條消息，指示這個人身高屬於平均水平。\n    else if ((PerHeight >= 165.0) && (PerHeight <= 195.0))   // 檢查 \'PerHeight\' 是否介於 165.0 和 195.0 之間。\n        printf("這個人是較高的。\\n");   // 印出一條消息，指示這個人身高較高。\n    else\n        printf("身高異常。\\n");   // 印出一條消息，指示身高異常。\n}\n \n \n 2.輸入攝氏度轉換華氏度 \n #include <stdio.h>     // 包含標準輸入/輸出頭文件。\n\nfloat temp_f;     /* 華氏度 */\nfloat temp_c;     /* 攝氏度 */\nchar line_text[50];        /* 一行輸入 */\n\nint main() {\n    printf("輸入溫度（攝氏度）：");  // 提示用戶輸入攝氏溫度。\n    fgets(line_text, sizeof(line_text), stdin);      // 從用戶讀取一行輸入並存儲在 \'line_text\' 中。\n    sscanf(line_text, "%f", &temp_c);               // 將 \'line_text\' 中的輸入轉換為浮點數並存儲在 \'temp_c\' 中。\n\n    temp_f = ((9.0 / 5.0) * temp_c) + 32.0;         // 將攝氏溫度轉換為華氏溫度並存儲在 \'temp_f\' 中。\n    printf("%f degrees Fahrenheit.\\n", temp_f);    // 以華氏度打印溫度。\n\n    return(0);   // 返回0以表示程序成功執行。\n}\n \n \n 3.用C語言函數獲取當前時間 \n #define __STDC_WANT_LIB_EXT1__ 1/這一行是一個預處理器指令，用來啟用C標準庫的擴展功能。在這裡，它啟用了擴展函數 ctime_s\n#include <time.h>/這裡包含了標準的時間頭文件，其中包含了一些與時間相關的函數和結構。\n#include <stdio.h> /這裡包含了標準的輸入/輸出頭文件，以便使用 printf 函數輸出信息。\n\nint main(void)/這是程序的主函數的開始\n{\n    time_t result = time(NULL);/使用 time 函數獲取當前的時間，返回的結果存儲在 result 變數中。\n    printf("\\n%s\\n", ctime(&result));/ 使用 ctime 函數將時間轉換為可讀的字符串格式，並通過 printf 函數打印出來。\n#ifdef __STDC_LIB_EXT1__/這是一個條件編譯指令，用於檢查是否支持標準庫的擴展功能。\n    char time_str[26];\n    ctime_s(time_str,sizeof time_str,&result);/如果支持擴展功能，則使用 ctime_s 函數將時間轉換為可讀的字符串格式，並將結果存儲在 time_str 中。\n    printf("\\n%s\\n", time_str);/通過 printf 函數打印使用 ctime_s 轉換後的時間字符串。\n#endif\n} \n \n 4.用C語言寫一個程式來列印目前日期和時間 \n #include <time.h>\n#include <stdio.h>  \n#include <stdlib.h>\n\nint main(void)\n{\n    time_t cur_time;         // 定義一個 time_t 型變數 cur_time 來存儲當前時間。\n    char* cur_t_string;      // 定義一個指向字符的指針 cur_t_string，用來存儲轉換後的時間字符串。\n\n    cur_time = time(NULL);   // 使用 time 函數獲取當前時間，並將其存儲在 cur_time 變數中。\n\n    if (cur_time == ((time_t)-1))\n    {\n        // 如果獲取當前時間失敗，輸出錯誤信息並以失敗的狀態退出程序。\n        (void) fprintf(stderr, "無法獲取當前日期和時間。\\n");\n        exit(EXIT_FAILURE);\n    }\n\n    cur_t_string = ctime(&cur_time); // 將 cur_time 中的時間轉換為本地時間格式，並將結果存儲在 cur_t_string 中。\n\n    if (cur_t_string == NULL)\n    {\n        // 如果轉換時間失敗，輸出錯誤信息並以失敗的狀態退出程序。\n        (void) fprintf(stderr, "無法轉換當前日期和時間。\\n");\n        exit(EXIT_FAILURE);\n    }\n\n    // 通過 printf 函數輸出轉換後的時間字符串。\n    (void) printf("\\n當前時間為：%s\\n", cur_t_string);\n\n    // 退出程序，表示成功執行。\n    exit(EXIT_SUCCESS);\n}\n \n \n 5.輸入名字、姓氏及出生年份 \n #include <stdio.h>    // 包含標準輸入/輸出頭文件。\n\nint main() {\n    char firstname[20], lastname[20];   // 宣告用於存儲名字和姓氏的字符數組，每個最大大小為20個字符。\n    int bir_year;   // 宣告一個整數變數 \'bir_year\' 來存儲出生年份。\n\n    printf("輸入您的名字：");   // 提示用戶輸入他們的名字。\n    scanf("%s", firstname);   // 讀取並將用戶的輸入存儲在 \'firstname\' 中。\n\n    printf("輸入您的姓氏：");   // 提示用戶輸入他們的姓氏。\n    scanf("%s", lastname);   // 讀取並將用戶的輸入存儲在 \'lastname\' 中。\n\n    printf("輸入您的出生年份：");   // 提示用戶輸入他們的出生年份。\n    scanf("%d", &bir_year);   // 讀取並將用戶的輸入存儲在 \'bir_year\' 中。\n\n    printf("%s %s %d\\n", firstname, lastname, bir_year);   // 打印名字、姓氏和出生年份。\n\n    return 0;   // 返回0以表示程序成功執行。\n}\n \n \n 6.檢查數字是否為醜數 \n # include <stdio.h>\n# include <string.h>\n\nint main()\n{\n    int n, x = 0;\n    printf("\\n\\n 檢查一個給定數字是否是醜數：\\n");\n    printf("----------------------------------------------------\\n");\n    printf("輸入一個整數數字：");\n    scanf("%d", &n);\n\n    if (n <= 0) {  \n        printf("輸入正確的數字。");  \n    }\n\n    while (n != 1) \n    {  \n        if (n % 5 == 0) \n        {  \n            n /= 5;  \n        } \n        else if (n % 3 == 0) \n        {  \n            n /= 3;  \n        } \n        else if (n % 2 == 0) \n        {  \n            n /= 2;  \n        } \n        else \n        {  \n            printf("它不是一個醜數。\\n"); \n            x = 1;  \n            break;  \n        }  \n    } \n\n    if (x == 0) \n    { \n        printf("它是一個醜數。\\n");\n    }\n    \n    return 0;\n}\n \n \n 7.將公里每小時轉換為英哩每小時 \n #include <stdio.h>     // 包含標準輸入/輸出頭文件。\nfloat kmph;              /* 每小時公里數 */\nfloat miph;              /* 每小時英里數（將要計算的） */\nchar  line_text[50];      /* 來自鍵盤的一行輸入 */\n\nint main()\n{\n    printf("輸入每小時公里數：");   // 提示用戶輸入每小時公里數。\n    fgets(line_text, sizeof(line_text), stdin);   // 從用戶讀取一行輸入並將其存儲在 \'line_text\' 中。\n    sscanf(line_text, "%f", &kmph);   // 將輸入轉換為浮點數並存儲在 \'kmph\' 中。\n\n    miph = (kmph * 0.6213712);   // 將每小時公里數轉換為每小時英里數。\n    printf("%f 英里每小時\\n", miph);   // 將結果以英里每小時打印出來。\n\n    return 0;   // 返回0以表示程序成功執行。\n}\n \n \n 8.顯示兩個整數變量 \n #include <stdio.h>\nvoid main(void)\n{\n    int m = 10, n, o;\n    int *z = &m;\n\n    printf("\\n\\n 指針：展示指針的基本聲明：\\n");\n    printf("-------------------------------------------------------\\n");\n    printf(" 這裡有 m=10，n 和 o 是兩個整數變量，*z 是一個整數\\n");\n    printf("\\n\\n z 存儲 m 的地址 = %p\\n", z); // z 是一個指針，所以 %p 會印出地址\n    printf("\\n *z 存儲 m 的值 = %i\\n", *z);\n    printf("\\n &m 是 m 的地址 = %p\\n", &m); // &m 給出整數變量 m 的地址，所以 %p 是對應的格式符號\n    printf("\\n &n 存儲 n 的地址 = %p\\n", &n);\n    printf("\\n &o 存儲 o 的地址 = %p\\n", &o);\n    printf("\\n &z 存儲 z 的地址 = %p\\n\\n", &z); // &z 給出指針 z 的存儲地址，仍然是一個地址，%p 是正確的格式符號\n}\n \n \n 9.輸入1-10的整數查看哪個為正確 \n #include<stdio.h>     // 包含標準輸入/輸出頭文件。\n#include<stdlib.h>    // 包含標準庫頭文件。\n#include<time.h>      // 包含時間頭文件，用於生成隨機數。\n\nint main ()           // 主函數的開始。\n{\n    int number, input;   // 宣告兩個整數變數 \'number\' 和 \'input\'。\n\n    srand ( time(NULL) );   // 使用當前時間初始化隨機種子。\n\n    number = rand() % 10 + 1;   // 生成一個介於1和10之間的隨機數並存儲在 \'number\' 中。\n\n    do {   // 開始一個do-while循環。\n        printf ("\\n猜測數字（1到10）：");   // 輸出提示用戶猜測數字的消息。\n        scanf ("%d", &input);    // 讀取用戶的輸入並存儲在 \'input\' 中。\n\n        if (number > input)   // 如果隨機數大於用戶的輸入。\n            printf ("該數字較大\\n");   // 輸出消息指示該數字較大。\n\n    } while (number != input);   // 只要用戶的輸入不等於隨機數，就繼續循環。\n\n    printf ("答對了！\\n\\n");   // 輸出消息指示用戶猜對了。\n\n    return 0;   // 返回0以表示程序成功執行。\n}   // 主函數的結尾。\n \n \n 10.輸入任意數的平方 \n #include <stdio.h>\n\ndouble square(double num)\n{\n    return (num * num);\n}\n\nint main()\n{\n    int num;\n    double n;\n\n    printf("\\n\\n 函數：計算任意數的平方 :\\n");\n    printf("------------------------------------------------\\n");\t\n\n    printf("輸入任意數以計算平方 : ");\n    scanf("%d", &num);\n\n    n = square(num);\n    printf("%d 的平方是 : %.2f\\n", num, n); \n\n    return 0;\n}\n \n \n 11.用 C 語言編寫程式以建立和顯示單向鏈表 \n #include <stdio.h>\n#include <stdlib.h>\n\n// 單向鏈表中節點的結構\nstruct node {\n    int num;                // 節點的數據\n    struct node *nextptr;   // 指向下一個節點的地址\n} *stnode;                  // 指向開始節點的指針\n\n// 函數原型\nvoid createNodeList(int n); // 創建鏈表的函數\nvoid displayList();         // 顯示鏈表的函數\n\n// 主函數\nint main() {\n    int n;\n\n    // 顯示程序的目的\n    printf("\\n\\n 單向鏈表：創建並顯示單向鏈表：\\n");\n    printf("-------------------------------------------------------------\\n");\n\n    // 輸入鏈表的節點數量\n    printf(" 輸入節點的數量：");\n    scanf("%d", &n);\n\n    // 創建具有n個節點的鏈表\n    createNodeList(n);\n\n    // 顯示輸入的鏈表數據\n    printf("\\n 鏈表中輸入的數據：\\n");\n    displayList();\n\n    return 0;\n}\n\n// 函數：創建具有n個節點的鏈表\nvoid createNodeList(int n) {\n    struct node *fnNode, *tmp;\n    int num, i;\n\n    // 為開始節點分配內存\n    stnode = (struct node *)malloc(sizeof(struct node));\n\n    // 檢查內存分配是否成功\n    if(stnode == NULL) {\n        printf(" 無法分配內存。");\n    } else {\n        // 從用戶輸入讀取開始節點的數據\n        printf(" 輸入第1個節點的數據：");\n        scanf("%d", &num);\n        stnode->num = num;      \n        stnode->nextptr = NULL; // 將下一個指針設置為NULL\n        tmp = stnode;\n\n        // 創建n個節點並將它們添加到鏈表中\n        for(i = 2; i <= n; i++) {\n            fnNode = (struct node *)malloc(sizeof(struct node));\n\n            // 檢查內存分配是否成功\n            if(fnNode == NULL) {\n                printf(" 無法分配內存。");\n     \n \n \n 12.實現樹結構的 C 程式 \n // 包含必要的頭文件\n#include <stdio.h>\n#include <stdlib.h>\n\n// 二叉樹節點的結構\nstruct TreeNode {\n    int data;\n    struct TreeNode* left;\n    struct TreeNode* right;\n};\n\n// 函數：創建一個新節點\nstruct TreeNode* createNode(int value) {\n    // 為一個新的TreeNode分配內存\n    struct TreeNode* newNode = (struct TreeNode*)malloc(sizeof(struct TreeNode));\n\n    // 檢查內存分配是否成功\n    if (newNode != NULL) {\n        // 初始化節點數據\n        newNode->data = value;\n        newNode->left = NULL;\n        newNode->right = NULL;\n    }\n\n    // 返回創建的節點\n    return newNode;\n}\n\n// 函數：將節點插入二叉樹\nstruct TreeNode* insertNode(struct TreeNode* root, int value) {\n    // 如果樹為空，則創建一個新節點\n    if (root == NULL) {\n        return createNode(value);\n    }\n\n    // 如果值小於根的數據，則插入到左子樹中\n    if (value < root->data) {\n        root->left = insertNode(root->left, value);\n    }\n    // 如果值大於根的數據，則插入到右子樹中\n    else if (value > root->data) {\n        root->right = insertNode(root->right, value);\n    }\n\n    // 返回修改後的根\n    return root;\n}\n\n// 函數：執行二叉樹的中序遍歷\nvoid inOrderTraversal(struct TreeNode* root) {\n    // 中序遍歷樹：左子樹、根、右子樹\n    if (root != NULL) {\n        inOrderTraversal(root->left);\n        printf("%d ", root->data);\n        inOrderTraversal(root->right);\n    }\n}\n\n// 函數：釋放分配給二叉樹的內存\nvoid freeTree(struct TreeNode* root) {\n    // 遞歸釋放整棵樹的內存\n    if (root != NULL) {\n        freeTree(root->left);\n        freeTree(root->right);\n        free(root);\n    }\n}\n\nint main() {\n    // 初始化二叉樹的根\n    struct TreeNode* root = NULL;\n    int nodeValue;\n    char choice;\n\n    // 用戶輸入循環，將節點插入二叉樹\n    do {\n        // 提示用戶輸入要插入二叉樹的值\n        printf("輸入要插入二叉樹的值：");\n        scanf("%d", &nodeValue);\n\n        // 將值插入二叉樹\n        root = insertNode(root, nodeValue);\n\n        // 問用戶是否要插入另一個節點\n        printf("是否要插入另一個節點？(y/n)：");\n        scanf(" %c", &choice);\n\n    } while (choice == \'y\' || choice == \'Y\');\n\n    // 顯示二叉樹的中序遍歷\n    printf("\\n二叉樹的中序遍歷：");\n    inOrderTraversal(root);\n    printf("\\n");\n\n    // 釋放分配給二叉樹的內存\n    freeTree(root);\n\n    // 返回0以表示成功執行\n    return 0;\n}\n \n \n 13.實現哈希表的 C 程式 \n // 包含必要的頭文件\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define TABLE_SIZE 10\n\n// 用於鍵值對的結構\nstruct KeyValuePair {\n    char key[50];\n    char value[50];\n    struct KeyValuePair* next;\n};\n\n// 用於哈希表的結構\nstruct HashTable {\n    int size;\n    struct KeyValuePair** table;\n};\n\n// 字符串的哈希函數（djb2算法）\nunsigned long hashFunction(const char* str) {\n    unsigned long hash = 5381;\n    int c;\n\n    while ((c = *str++) != \'\\0\') {\n        hash = ((hash << 5) + hash) + c; // hash * 33 + c\n    }\n\n    return hash;\n}\n\n// 函數：創建一個新的鍵值對\nstruct KeyValuePair* createKeyValuePair(const char* key, const char* value) {\n    struct KeyValuePair* newPair = (struct KeyValuePair*)malloc(sizeof(struct KeyValuePair));\n    if (newPair != NULL) {\n        strcpy(newPair->key, key);\n        strcpy(newPair->value, value);\n        newPair->next = NULL;\n    }\n    return newPair;\n}\n\n// 函數：創建一個新的哈希表\nstruct HashTable* createHashTable(int size) {\n    struct HashTable* newTable = (struct HashTable*)malloc(sizeof(struct HashTable));\n    if (newTable != NULL) {\n        newTable->size = size;\n        newTable->table = (struct KeyValuePair**)calloc(size, sizeof(struct KeyValuePair*));\n    }\n    return newTable;\n}\n\n// 函數：將一個鍵值對插入哈希表\nvoid insert(struct HashTable* hashTable, const char* key, const char* value) {\n    unsigned long index = hashFunction(key) % hashTable->size;\n\n    // 創建一個新的鍵值對\n    struct KeyValuePair* newPair = createKeyValuePair(key, value);\n\n    // 在鏈表的開頭插入新對\n    newPair->next = hashTable->table[index];\n    hashTable->table[index] = newPair;\n}\n\n// 函數：檢索與鍵關聯的值\nconst char* retrieve(struct HashTable* hashTable, const char* key) {\n    unsigned long index = hashFunction(key) % hashTable->size;\n    struct KeyValuePair* current = hashTable->table[index];\n\n    // 遍歷索引處的鏈表\n    while (current != NULL) {\n        if (strcmp(current->key, key) == 0) {\n            return current->value; // 找到鍵，返回值\n        }\n        current = current->next;\n    }\n    return "未找到鍵"; // 未找到鍵\n}\n\n// 函數：顯示哈希表的內容\nvoid displayHashTable(struct HashTable* hashTable) {\n    for (int i = 0; i < hashTable->size; i++) {\n        printf("[%d] -> ", i);\n\n        struct KeyValuePair* current = hashTable->table[i];\n        while (current != NULL) {\n            printf("(%s, %s) -> ", current->key, current->value);\n            current = current->next;\n        }\n\n        printf("NULL\\n");\n    }\n}\n\n// 函數：釋放分配給哈希表的內存\nvoid freeHashTable(struct HashTable* hashTable) {\n    for (int i = 0; i < hashTable->size; i++) {\n        struct KeyValuePair* current = hashTable->table[i];\n        while (current != NULL) {\n            struct KeyValuePair* temp = current;\n            current = current->next;\n            free(temp);\n        }\n    }\n\n    free(hashTable->table);\n    free(hashTable);\n}\n\nint main() {\n    struct HashTable* hashTable = createHashTable(TABLE_SIZE);\n\n    // 插入鍵值對\n    insert(hashTable, "Red", "#ff0000");\n    insert(hashTable, "Green", "008000");\n    insert(hashTable, "Blue", "#0000FF");\n    insert(hashTable, "Yellow", "#FFFF00");\n    insert(hashTable, "Orange", "#FFA500");\n\n    printf("初始哈希表:\\n");\n    displayHashTable(hashTable);\n    printf("\\n");\n\n    // 檢索並打印特定鍵的值\n    printf("鍵\'Red\'的值：%s\\n", retrieve(hashTable, "Red"));\n    printf("鍵\'Yellow\'的值：%s\\n", retrieve(hashTable, "Yellow"));\n    printf("鍵\'White\'的值：%s\\n", retrieve(hashTable, "White"));\n    printf("\\n");\n\n    // 釋放分配的內存\n    freeHashTable(hashTable);\n\n    return 0;\n}\n \n \n 14.C For 迴圈 \n #include <stdio.h> // 包含標準輸入/輸出頭文件。\n\nint main() \n{\n   int i, j; // 声明用于迭代的變量。\n   char alph = \'A\'; // 初始化一個字符變量為 \'A\'。\n   int n, blk; // 声明用戶輸入和區塊計數的變量。\n   int ctr = 1; // 初始化計數器。\n\n   printf("輸入金字塔中字母的數量（小於26）：");\n   scanf("%d", &n); // 提示用戶輸入並將其存儲在變量 \'n\' 中。\n\n   for (i = 1; i <= n; i++) // 外部循環，用於行。\n   {\n       for(blk = 1; blk <= n - i; blk++) // 循環以在字母之前打印空格。\n           printf("  ");\n\n       for (j = 0; j <= (ctr / 2); j++) // 循環以按升序打印字母。\n       {\n           printf("%c ", alph++);\n       }\n\n       alph = alph - 2; // 在打印一半後減少字符。\n\n       for (j = 0; j < (ctr / 2); j++) // 循環以按降序打印字母。\n       {\n           printf("%c ", alph--);\n       }\n\n       ctr = ctr + 2; // 為下一行增加計數器。\n       alph = \'A\'; // 將字符重置為 \'A\' 以供下一行使用。\n\n       printf("\\n"); // 在打印一行後移到下一行。\n   }\n    return 0;  // 表示程序已成功執行。\n}\n \n \n 15.編寫一個 C 程式來反轉給定整數的數位 \n #include <stdio.h>\nint reverse(int n) {\n    int d, y = 0;\n    while (n) {\n        d = n % 10;\n        if ((n > 0 && y > (0x7fffffff - d) / 10) ||\n            (n < 0 && y < ((signed)0x80000000 - d) / 10)) {\n            return 0;  \n        }\n        y = y * 10 + d;\n        n = n / 10;\n    }\n    return y;  \n}\n\nint main(void)\n{\n    int i = 123;\n    printf("原始整數: %d  ", i);\n    printf("\\n反轉後的整數: %d  ", reverse(i));\n    i = 208478933;\n    printf("\\n原始整數: %d  ", i);\n    printf("\\n反轉後的整數: %d  ", reverse(i));\n    i = -73634;\n    printf("\\n原始整數: %d  ", i);\n    printf("\\n反轉後的整數: %d  ", reverse(i));\n    return 0;\n}\n \n \n 16.C 遞歸 \n #include<stdio.h>\n \nint term;\nint fibonacci(int prNo, int num);\n \nvoid main() \n{\n   static int prNo = 0, num = 1;\n\tprintf("\\n\\n 遞歸 : 打印斐波那契數列 :\\n");\n\tprintf("-----------------------------------------\\n");   \n \n   printf(" 輸入要打印的數列項數 (< 20) : ");\n   scanf("%d", &term);\n printf(" 數列為 :\\n"); \n   printf(" 1  ");\n   fibonacci(prNo, num);\n    printf("\\n\\n");\n}\n \nint fibonacci(int prNo, int num) \n{\n   static int i = 1;\n   int nxtNo;\n \n   if (i == term)\n      return (0);\n   else \n   {\n      nxtNo = prNo + num;\n      prNo = num;\n      num = nxtNo;\n      printf("%d  ", nxtNo);\n \n      i++;\n      fibonacci(prNo, num); // 遞歸，調用 fibonacci 函數本身\n   }\n   return (0);\n}\n \n \n 17.編寫一個 C 程式以使用內聯函數計算兩個整數的最小值 \n #include <stdio.h>\n\ninline int min(int x, int y) {\n  return (x < y) ? x : y;\n}\n\nint main() {\n  int a = 110, b = 120;\n  printf("%d 和 %d 的最小值是 %d\\n", a, b, min(a, b));\n  a = -110, b = -120;\n  printf("%d 和 %d 的最小值是 %d\\n", a, b, min(a, b));\n  return 0;\n}\n \n \n 18.創建名為“Employee”的結構來存儲員工詳細資訊，例如員工ID、姓名和工資。編寫程式，輸入三名員工的數據，找到薪水最高的員工，並顯示他們的資訊。 \n #include <stdio.h>\n\n// 定義結構 "Employee"\nstruct Employee {\n    int employeeID;\n    char name[50];\n    float salary;\n};\n\nint main() {\n    // 声明變量以存儲三名員工的詳細信息\n    struct Employee employee1, employee2, employee3;\n\n    // 輸入第一名員工的詳細信息\n    printf("輸入第一名員工的詳細信息:\\n");\n    printf("員工ID: ");\n    scanf("%d", &employee1.employeeID);\n    printf("姓名: ");\n    scanf("%s", employee1.name); // 假設名字不包含空格\n    printf("薪資: ");\n    scanf("%f", &employee1.salary);\n\n    // 輸入第二名員工的詳細信息\n    printf("\\n輸入第二名員工的詳細信息:\\n");\n    printf("員工ID: ");\n    scanf("%d", &employee2.employeeID);\n    printf("姓名: ");\n    scanf("%s", employee2.name);\n    printf("薪資: ");\n    scanf("%f", &employee2.salary);\n\n    // 輸入第三名員工的詳細信息\n    printf("\\n輸入第三名員工的詳細信息:\\n");\n    printf("員工ID: ");\n    scanf("%d", &employee3.employeeID);\n    printf("姓名: ");\n    scanf("%s", employee3.name);\n    printf("薪資: ");\n    scanf("%f", &employee3.salary);\n\n    // 找到薪資最高的員工\n    struct Employee highestSalaryEmployee;\n    if (employee1.salary >= employee2.salary && employee1.salary >= employee3.salary) {\n        highestSalaryEmployee = employee1;\n    } else if (employee2.salary >= employee1.salary && employee2.salary >= employee3.salary) {\n        highestSalaryEmployee = employee2;\n    } else {\n        highestSalaryEmployee = employee3;\n    }\n\n    // 顯示薪資最高的員工信息\n    printf("\\n薪資最高的員工:\\n");\n    printf("員工ID: %d\\n", highestSalaryEmployee.employeeID);\n    printf("姓名: %s\\n", highestSalaryEmployee.name);\n    printf("薪資: %.2f\\n", highestSalaryEmployee.salary);\n\n    return 0;\n}\n \n \n 19.編寫一個 C 程式來讀取候選人的年齡並確定他是否有資格投票 \n #include <stdio.h>   // 包含標準輸入/輸出頭文件。\n\nvoid main()\n{\n  int vote_age;   // 声明一個整數變量 \'vote_age\' 以存儲候選人的年齡。\n\n  printf("輸入候選人的年齡 : ");   // 提示用戶輸入候選人的年齡。\n  scanf("%d",&vote_age);   // 讀取並將用戶的輸入存儲在 \'vote_age\' 中。\n\n  if (vote_age < 18)   // 檢查 \'vote_age\' 是否小於18。\n  {\n    printf("對不起，您無資格投票。\\n");   // 印出一條消息，指示候選人無資格投票。\n    printf("您將在 %d 年後有資格投票。\\n", 18 - vote_age);   // 印出候選人有資格投票所需的年數。\n  }\n  else\n    printf("恭喜！您有資格投票。\\n");   // 印出一條消息，指示候選人有資格投票。\n}\n \n \n 20. 編寫一個 C 程式以使用哈希 （#） 列印塊 F，其中 F 的高度為 6 個字元，寬度為 5 個字元和 4 個字元。 \n \n #include <stdio.h>\n\nint main() \n{\n    // 打印一行井號\n    printf("######\\n");\n    \n    // 打印一個單獨的井號\n    printf("#\\n");\n    \n    // 打印一個單獨的井號\n    printf("#\\n");\n    \n    // 打印一行井號\n    printf("#####\\n");\n    \n    // 打印一個單獨的井號\n    printf("#\\n");\n    \n    // 打印一個單獨的井號\n    printf("#\\n");\n    \n    // 打印一個單獨的井號\n    printf("#\\n");\n\n    return(0);\n}\n \n \n \n \n \n \n \n', 'tags': '', 'url': 'ANSIC.html'}, {'title': 'c_ex', 'text': '', 'tags': '', 'url': 'c_ex.html'}, {'title': '練習一', 'text': '1.(||)運算元傳回值與 (&&) 一樣, 但不同的是, 當 (||) 運算元兩邊的運算子之值都為 0 時, 則會傳回 0, 否則傳回 1 \n /* ====================\n   邏輯或運算子。\n==================== */\n#include <stdio.h>\n\nvoid main()\n{\n    printf("%d\\n", 1 || 0);\n    printf("%d\\n", 0 || 0);\n    printf("%d\\n", 2 || 2);\n}\n \n \n 2.sizeof( type ) 取得特定型別的 size \n /* ====================\n   sizeof 的範例。\n==================== */\n#include <stdio.h>\n\nvoid main()\n{\n    char a;\n    printf("int 的大小為 %d \\n", sizeof(int));\n    printf("char a 的大小為 %d \\n", sizeof(a));\n}\n \n \n 3.C 有3個邏輯運算元, 基本上常與條件判斷運算合用 \n /* ====================\n   邏輯非運算子。\n==================== */\n#include <stdio.h>\n\nvoid main()\n{\n    int a;\n    a = 3;\n    printf("%d\\n", !a);\n    a = 0;\n    printf("%d\\n", !a);\n}\n \n \n 4.位元運算元 \n /* ====================\n   位元運算子的範例。\n==================== */\n#include<stdio.h>\n\nvoid main()\n{\n    int a, b;\n    a = 15;\n    b = 1;\n\n    printf("%d \\n", a | b ); /* a OR b */\n    printf("%d \\n", a & b ); /* a AND b */\n    printf("%d \\n", a ^ b ); /* a XOR b */\n    printf("%d \\n", a << 1 ); /* a 位元左移 1 位 */\n    printf("%d \\n", a >> 1 ); /* a 位元右移一位 */\n    printf("%d \\n", ~a ); /* A 的補數運算 */\n}\n \n \n 5. 關係運算元 \n /* ====================\n   關係運算子的範例。\n==================== */\n#include <stdio.h>\n\nint main()\n{\n    int a = 10, b = 5;\n\n    printf(" a == b 是 %d \\n", a == b);\n    printf(" a > b 是 %d \\n", a > b);\n    printf(" a < b 是 %d \\n", a < b);\n    printf(" a >= b 是 %d \\n", a >= b);\n    printf(" a <= b 是 %d \\n", a <= b);\n    printf(" a != b 是 %d \\n", a != b);\n\n    printf("\\n");\n\n    b = 10;\n\n    printf(" a == b 是 %d \\n", a == b);\n    printf(" a > b 是 %d \\n", a > b);\n    printf(" a < b 是 %d \\n", a < b);\n    printf(" a >= b 是 %d \\n", a >= b);\n    printf(" a <= b 是 %d \\n", a <= b);\n    printf(" a != b 是 %d \\n", a != b);\n\n    return 0;\n}\n \n \n 6.算術運算元 \n /* ====================\n   基本運算範例。\n==================== */\n#include<stdio.h>\n\nint main()\n{\n    int a, b;\n    a = 10; \n    b = 3;\n\n    printf("%d \\n", a * b );  /* 乘法 */\n    printf("%d \\n", a / b );  /* 除法 */\n    printf("%d \\n", a + b );  /* 加法 */\n    printf("%d \\n", a - b );  /* 減法 */\n    printf("%d \\n", a % b );  /* 取餘數 */\n\n    return 0;\n}\n \n \n 7.C 的基本型態\xa0 \n /* ====================\n   變數宣告的例子 2。\n==================== */\nint main()\n{\n    /* 變數宣告 */\n    int a;\n    int A;\n    int b, c;\n\n    a = 1;\n    A = 8;\n    b = 2;\n    c = A - a + b; /* 先計算 A - a + b，將結果傳回給 c */\n    printf("%d", c); /* 使用 printf 印出 c 這個整數型態的變數 */\n\n    return 0;\n}\n \n \n 8.C 的基本型態\xa0 \n /* ====================\n   變數宣告的例子 3。\n==================== */\n#include <stdio.h>\n\nint main()\n{\n    int a = 1;\n    int A = 8;\n    int b = 2, c;\n\n    c = A - a + b;\n\n    /* 輸出 a, A, b, c 到螢幕 */\n    printf("a = %d, A = %d, b = %d, c = %d ", a, A, b, c);\n\n    return 0;\n}\n \n \n 9.C 的浮點數 \n #include <stdio.h>\n\nvoid main()\n{\n    float a = 0.5;\n    double b = 1.2;\n    int c = 3;\n\n    b = b + a + c;\n\n    /* 輸出 a, b, c 到螢幕 */\n    printf(" a = %3.1f, b = %3.1f, c = %d ", a, b, c);\n}\n \n \n 10.C 的輸出與輸入的函數 \n /* =========================\n   輸入一個整數\n========================= */\n#include <stdio.h>\n\nint main()\n{\n    int i;\n    printf("輸入一個整數:");\n    scanf("%d", &i); /* 在變數 i 的前面加上 &（位址運算元） */\n    printf("輸入的數字是 %d", i);\n\n    return 0;\n}\n \n \n 11.使用 C 的標準輸出函數  \n /* ====================\n   印出你好，世界！\n==================== */\n#include <stdio.h>\n\nvoid main()\n{\n    /* 印出 Hello World! */\n    printf("Hello World!");\n}\n \n \n 12.使用 C 的標準輸出函數 \n /* ====================\n   打印出你好，世界！再见再见。\n==================== */\n#include <stdio.h>\n\nint main()\n{\n    /* 打印出 Hello World! 再见再见 */\n    printf("Hello World! ");\n    printf("Bye ");\n    printf("Bye");\n    return 0;\n}\n \n \n 13.C的字元 \n /* ====================\n   字符示例 1\n==================== */\n#include <stdio.h>\n\nint main()\n{\n    char x, y;\n    x = \'a\';\n    y = (char)97;\n    /* 输出 x, y, x，最后一个是以 ASCII 值显示 y */\n    printf(" x = %c, y = %c, y 的 ASCII 值 = %d", x, y, y);\n    return 0;\n}\n \n \n 14.邏輯運算元 \n /* ====================\n   邏輯非（Logical NOT）。\n==================== */\n#include <stdio.h>\n\nvoid main()\n{\n    int a;\n    a = 3;\n    printf("%d\\n", !a);\n    a = 0;\n    printf("%d\\n", !a);\n}\n \n \n 15.C 的 Array (陣列) \n /* ====================\n   陣列 - 1。\n==================== */\n#include <stdio.h>\n\nint main()\n{\n    int grade[5]; /* 大小為5的陣列 */\n    int i;\n\n    grade[0] = 75; /* 第1個元素 */\n    grade[1] = 80; /* 第2個元素 */\n    grade[2] = 85; /* 第3個元素 */\n    grade[3] = 70; /* 第4個元素 */\n    grade[4] = 90; /* 第5個元素 */\n\n    for (i = 0; i < 5; i++)\n    {\n        printf("第 %d 個數字 = %d\\n", i, grade[i]);\n    }\n\n \n \n 16.C 的流程控制 \n /* ====================\n   do - while 循環。\n==================== */\n#include <stdio.h>\n\nvoid main()\n{\n    int i, j;\n    i = 0;\n    j = 10; /* 在循環之外先設定初始值 */\n\n    do\n    {\n        printf("i = %d, ", i);\n        printf("j = %d \\n", j);\n        i++;\n        j++;\n    } while (i < 6); /* 檢查條件的地方 */\n}\n \n \n 17.函數 (Function) \n /* ====================\n   函數 (2)\n==================== */\n#include <stdio.h>\n\nfloat circle(int r); /* 宣告 circle 的原型 */\n\nvoid main()\n{\n    float answer;\n    answer = circle(8);\n    printf("圓周長度是 %f", answer);\n}\n\n/* ====================\n   circle 函數，計算圓的周長\n==================== */\nfloat circle(int r)\n{\n    float result;\n    result = 3.14159 * (double)2 * r;\n    return (result);\n}\n \n \n 18.C 的流程控制 \n /* ====================\n   switch - case 的示例 1。\n==================== */\n#include <stdio.h>\n\nvoid main()\n{\n    char c;\n    printf("輸入一個字符：");\n    scanf("%c", &c);\n\n    switch (c)\n    {\n    case \'a\':\n        printf("你按下了 a ");\n        break;\n    case \'b\':\n        printf("你按下了 b ");\n        break;\n    case \'c\':\n        printf("你按下了 c ");\n        break;\n    default:\n        printf("不是 a、b、c ");\n        break;\n    }\n}\n \n \n 19.邏輯運算元 \n /* ====================\n   邏輯 AND。\n==================== */\n#include <stdio.h>\n\nvoid main()\n{\n    printf("%d\\n", 1 && 3);\n    printf("%d\\n", 0 && 0);\n    printf("%d\\n", 2 && 2);\n}\n \n \n 20.C 的流程控制 \n /* ====================\n   99 乘法表。\n==================== */\n#include <stdio.h>\n\nint main()\n{\n    int x, y;\n\n    for (x = 1; x <= 9; x++)\n    {\n        for (y = 1; y <= 9; y++)\n        {\n            printf("%d ", x * y);\n        }\n        printf("\\n");\n    }\n\n    return 0;\n}\n \n \n \n \n \n \n', 'tags': '', 'url': '練習一.html'}, {'title': '練習二', 'text': '1.將兩個數位相乘 \n #define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n\n/* 乘法計算兩個浮點數 */\nint main()\n{\n    float this_is_a_number1, this_is_a_number2, total;\n    \n    printf("請輸入一個數字：\\n ");\n    scanf("%f", &this_is_a_number1); /* 讀取數字 */\n    printf("你輸入了 %f\\n", this_is_a_number1);\n    \n    printf("請再輸入一個數字：\\n");\n    scanf("%f", &this_is_a_number2); /* 讀取數字 */\n    printf("你輸入了 %f\\n", this_is_a_number2);\n    \n    total = this_is_a_number1 * this_is_a_number2; /* 乘法運算 */\n    printf("兩數的積為 %f\\n", total);\n    \n    return 0;\n}\n \n \n 2.數字的總和 \n #define _CRT_SECURE_NO_WARNINGS\n#include<stdio.h>\n\n/* 演示使用 for 迴圈 */\nint main()\n{\n    float this_is_a_number, total;\n    int i;\n\n    total = 0;\n\n    /* for 迴圈執行 10 次 */\n    for (i = 0; i < 10; i++)\n    {\n        printf("請輸入一個數字：\\n ");\n        scanf("%f", &this_is_a_number); /* 讀取數字 */\n        total = total + this_is_a_number;\n    }\n\n    printf("總和為 = %f\\n", total);\n\n    return 0;\n}\n \n \n 3.判斷數字大小 \n #include <stdio.h>\n/* if 操作的範例 */\nint main()\n{\n    int this_is_a_number;\n    printf("請輸入一個介於1和10之間的整數：\\n ");\n    scanf("%d", &this_is_a_number);\n    if (this_is_a_number < 6)\n        printf("這個數字小於6；\\n ");\n\n    printf("請輸入一個介於10和20之間的整數：\\n ");\n    scanf("%d", &this_is_a_number);\n    if (this_is_a_number < 16)\n        printf("這個數字小於16\\n ");\n    else\n        printf("這個數字大於15\\n ");\n\n    return 0;\n}\n \n \n 4.陣列 \n #define _CRT_SECURE_NO_WARNINGS\n#include<stdio.h>\n\n/* 展示使用陣列的程式 */\nint main()\n{\n    int arr1[8]; /* 定義包含8個整數的陣列 */\n    int i;\n\n    printf("輸入8個整數數字\\n");\n    for (i = 0; i < 8; i++)\n    {\n        scanf("%d", &arr1[i]); /* 讀取到 arr1[i] */\n    }\n\n    printf("您的8個數字是\\n");\n    for (i = 0; i < 8; i++)\n    {\n        printf("%d ", arr1[i]);\n    }\n    printf("\\n");\n\n    return 0;\n}\n \n \n 5.sizeof命令 \n /* 程式示範使用 sizeof 命令 */\n#include <stdio.h>\n#include <limits.h>\n#include <math.h>\n\nint main() {\n    int sizeofint;\n    unsigned int sizeofunsint;\n    float sizeoffloat;\n    double sizeofdouble;\n\n    printf("int 的儲存空間大小：%lu 位元組\\n", sizeof(sizeofint));\n    printf("unsigned int 的儲存空間大小：%lu 位元組\\n", sizeof(sizeofunsint));\n    printf("float 的儲存空間大小：%lu 位元組\\n", sizeof(sizeoffloat));\n    printf("double 的儲存空間大小：%lu 位元組\\n", sizeof(sizeofdouble));\n\n    return 0;\n}\n \n \n 6.陳述 \n #include <stdio.h> /* 展示使用 goto 陳述句 */\nint main()\n{\n    int i, testvalue;\n    testvalue = 2;\n    for (i = 0; i < 10; i++)\n    {\n        if (testvalue == 2)\n            goto error;\n    }\n    printf("正常退出 for 迴圈\\n");\nerror:\n    printf("testvalue 為 %d\\n", testvalue);\n}\n \n \n 7.介於1-5的整數 \n #define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n\n/* switch 操作的範例 */\nint main()\n{\n    int this_is_a_number;\n    printf("請輸入介於1和5之間的整數:\\n ");\n    scanf("%d", &this_is_a_number);\n\n    switch (this_is_a_number)\n    {\n    case 1:\n        printf("Case 1: 值為：%d", this_is_a_number);\n        break;\n    case 2:\n        printf("Case 2: 值為：%d", this_is_a_number);\n        break;\n    case 3:\n        printf("Case 3: 值為：%d", this_is_a_number);\n        break;\n    case 4:\n        printf("Case 4: 值為：%d", this_is_a_number);\n        break;\n    case 5:\n        printf("Case 5: 值為：%d", this_is_a_number);\n        break;\n    default:\n        printf("錯誤，值為：%d", this_is_a_number); /* 輸入的數字不在1到5之間 */\n    }\n\n    return 0;\n}\n \n \n 8.陣列 \n #include <stdio.h>\n\nint main() {\n    int arr1[100][100]; /* 假設陣列大小不超過100x100 */\n    int i, j, k, l;\n\n    printf("請輸入陣列的行數和列數（以空格分隔）：\\n");\n    scanf("%d %d", &k, &l);\n\n    printf("請輸入陣列的元素：\\n");\n    for (i = 0; i < k; i++) {\n        for (j = 0; j < l; j++) {\n            scanf("%d", &arr1[i][j]);\n        }\n    }\n\n    printf("您的陣列是：\\n");\n    for (i = 0; i < k; i++) {\n        for (j = 0; j < l; j++) {\n            printf("%d ", arr1[i][j]);\n        }\n        printf("\\n");\n    }\n\n    return 0;\n}\n \n \n 9.函數 \n #define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n\n/* 這段程式碼演示了一個函式的作用 */\n/* 這個函式比較兩個數字並告訴哪一個更大 */\n/* 使用者輸入三個數字，得知它們之間的大小關係！ */\n\nvoid myfunction(int a, int b); /* 函式及其參數的宣告 */\nint first, second, third;\n\nint main()\n{\n    printf("請輸入第一個整數：");\n    scanf("%d", &first);\n    printf("請輸入第二個整數：");\n    scanf("%d", &second);\n    printf("請輸入第三個整數：");\n    scanf("%d", &third);\n\n    myfunction(first, second);\n    myfunction(first, third);\n    myfunction(second, third);\n\n    return 0;\n}\n\nvoid myfunction(int a, int b)\n/* 這個函式在程式的 main{} 部分之外 */\n/* 這個函式僅比較兩個參數 a 和 b，並告訴哪個更大 */\n{\n    if (a > b)\n        printf("%d 大於 %d\\n", a, b);\n    else if (a < b)\n        printf("%d 大於 %d\\n", b, a);\n    else\n        printf("%d 和 %d 相等\\n", a, b);\n}\n \n \n 10.函式 \n /* 返回答案的函式 */\n/* 找到學校一年級中成績最高的學生 */\n#include <stdio.h>\n\ndouble getmarks(double pupils[]);\n\nint main()\n{\n    double pupil;\n\n    /* 存放班級成績的數組在程式主體中預設 */\n    double marks[] = {10.6, 23.7, 67.9, 93.0, 64.2, 33.8, 57.5, 82.2, 50.7, 45.7};\n\n    /* 調用 getmarks 函式。該函式返回最高成績，然後將其存儲在 pupil 中 */\n    pupil = getmarks(marks);\n\n    printf("最高成績是 = %f", pupil);\n\n    return 0;\n}\n\ndouble getmarks(double pupils[])\n{\n    int i;\n    double highest;\n\n    highest = 0;\n\n    /* 依次遍歷所有學生，存儲最高成績 */\n    for (i = 0; i < 10; ++i)\n    {\n        if (highest < pupils[i])\n            highest = pupils[i];\n    }\n\n    return highest; /* 將 highest 中的值返回到調用函式的地方 */\n}\n \n \n 11.結構 \n /* 結構範例程式 */\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <string.h>\n\n/* 定義結構 */\nstruct Student {\n    int id;\n    char name[16];\n    double percent;\n};\n\nint main() {\n    /* 定義兩個屬於 "Student" 類型的數據位置 */\n    struct Student s1, s2;\n\n    /* 為 s1 結構賦值 */\n    s1.id = 56;\n    strcpy(s1.name, "Rob Smith");\n    s1.percent = 67.4;\n\n    /* 輸出結構 s1 */\n    printf("\\nid：%d", s1.id);\n    printf("\\n姓名：%s", s1.name);\n    printf("\\n百分比：%lf", s1.percent);\n\n    /* 為 s2 結構賦值 */\n    s2.id = 73;\n    strcpy(s2.name, "Mary Gallagher");\n    s2.percent = 93.8;\n\n    /* 輸出結構 s2 */\n    printf("\\nid：%d", s2.id);\n    printf("\\n姓名：%s", s2.name);\n    printf("\\n百分比：%l\n \n \n 12.C語言 \n /* 這是我的第一個 C 語言程式 */\nint main()\n{\n    printf("我的第一個程式\\n");\n    return 0;\n}\n \n \n 13.輸入、輸出 \n #include <stdio.h>\n\n/* 讀取並顯示一個字符 */\nint main() {\n    char c;\n\n    printf("輸入字符：");\n    c = getchar(); /* 讀取輸入的字符 */\n    \n    printf("輸入的字符是：");\n    putchar(c); /* 輸出字符 */\n\n    return 0;\n}\n \n \n 14.兩個數字的總和 \n /* 將兩個浮點數相加 */\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n\nint main() {\n    float this_is_a_number1, this_is_a_number2, total;\n\n    printf("請輸入一個數字：\\n");\n    scanf("%f", &this_is_a_number1); /* 讀取十進制數字 */\n    printf("您輸入的數字為 %f\\n", this_is_a_number1);\n\n    printf("請再輸入一個數字：\\n");\n    scanf("%f", &this_is_a_number2); /* 讀取十進制數字 */\n    printf("您輸入的數字為 %f\\n", this_is_a_number2);\n\n    total = this_is_a_number1 + this_is_a_number2; /* 將兩數相加 */\n    printf("總和為 %f\\n", total);\n\n    return 0;\n}\n \n \n 15.字元開關範例 \n #define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n\n/* 使用字元開關的範例 */\nint main()\n{\n    char this_is_a_character;\n\n    printf("請輸入字元 a、b、c、d 或 e:\\n ");\n    scanf("%c", &this_is_a_character);\n\n    switch (this_is_a_character)\n    {\n    case \'a\':\n        printf("輸入了 a");\n        break;\n    case \'b\':\n        printf("輸入了 b");\n        break;\n    case \'c\':\n        printf("輸入了 c");\n        break;\n    case \'d\':\n        printf("輸入了 d");\n        break;\n    case \'e\':\n        printf("輸入了 e");\n        break;\n    default:\n        printf("預設情況 ");\n    }\n\n    return 0;\n}\n \n \n 16.字串操作 \n #define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <string.h>\n\n/* 示範字串操作的程式 strlen、strcpy、strcat、strcmp */\nint main() {\n    char borrow[7] = {\'b\', \'o\', \'r\', \'r\', \'o\', \'w\', \'\\0\'};\n    char string1[32] = "This is string1";\n    char string2[16] = "This is string2";\n    char string3[16];\n    int len;\n\n    /* 列印出字串的長度 */\n    len = strlen(string1);\n    printf("strlen(string1) : %d\\n", len);\n    len = strlen(string2);\n    printf("strlen(string2) : %d\\n", len);\n    len = strlen(string3);\n    printf("strlen(string3) : %d\\n", len);\n\n    /* 將字串1複製到字串3中 */\n    strcpy(string3, string1);\n    printf("strcpy( string3, string1) : %s\\n", string3);\n    len = strlen(string3);\n    printf("strlen(string3) after copy of string1 into string3 : %d\\n", len);\n\n    /* 比較 string1 和 string3 （這些應該是相同的）*/\n    if (strcmp(string1, string3) == 0)\n        printf("字串相同\\n");\n\n    /* 連接 string1 和 string2 */\n    strcat(string1, string2);\n    printf("strcat( string1, string2): %s\\n", string1);\n\n    /* 連接後 string1 的總長度 */\n    len = strlen(string1);\n    printf("strlen(string1) after cat of string2\n \n \n 17.二維陣列 \n #define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n\n/* 二維數組測試範例 */\nint main() {\n    int arr1[7][8];\n    int i, j, k, l;\n\n    printf("輸入行數和列數（最多 7 行最多 8 列）\\n");\n    scanf("%d %d", &k, &l);\n\n    if (k > 7 || l > 8) {\n        printf("錯誤 — 行數最多為 7 列數最多為 8\\n");\n    } else {\n        printf("輸入陣列\\n");\n        for (i = 0; i < k; i++) {\n            for (j = 0; j < l; j++) {\n                scanf("%d", &arr1[i][j]);\n            }\n        }\n\n        printf("您的陣列是\\n");\n        for (i = 0; i < k; i++) {\n            for (j = 0; j < l; j++) {\n                printf("%d ", arr1[i][j]);\n            }\n            printf("\\n");\n        }\n    }\n\n    printf("陣列的第一行\\n");\n    for (j = 0; j < l; j++) {\n        printf("%d ", arr1[0][j]);\n    }\n    printf("\\n");\n\n    return 0;\n}\n \n \n 18.兩數相除 \n #define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n\n/* 兩個浮點數相除 */\nint main() {\n    float this_is_a_number1, this_is_a_number2, total;\n\n    printf("請輸入一個數字：\\n");\n    scanf("%f", &this_is_a_number1); /* 讀取數字 */\n    printf("您輸入了 %f\\n", this_is_a_number1);\n\n    printf("請再輸入一個數字：\\n ");\n    scanf("%f", &this_is_a_number2); /* 讀取數字 */\n    printf("您輸入了 %f\\n", this_is_a_number2);\n\n    total = this_is_a_number1 / this_is_a_number2; /* 除以數字 */\n    printf("商為 %f\\n", total);\n\n    return 0;\n}\n \n \n 19.循環 \n #define _CRT_SECURE_NO_WARNINGS\n#include<stdio.h>\n\n/* 演示 do 循環 */\nint main() {\n    float this_is_a_number, total;\n    int i;\n    total = 0;\n    i = 0;\n\n    /* do 循環循環直到 i 的值達到 10 */\n    do {\n        printf("請輸入一個數字：\\n ");\n        scanf("%f", &this_is_a_number);\n        total = total + this_is_a_number;\n        i++;\n    } while (i < 10);\n\n    printf("總和為 %f\\n", total);\n\n    return 0;\n}\n \n \n 20.顯示字元程序 \n #define _CRT_SECURE_NO_WARNINGS\n#include<stdio.h>\n/* 顯示字元數組使用的程序 */\nint main()\n{\nchar arr2[10];/* 定義 10 個字元的數組 */\nint i;\nprintf("enter 10 characters \\n");\nfor (i = 0;i < 10;i++)\n{\nscanf("%c", &arr2[i]);\n}\nprintf("Your 10 characters are \\n");\nfor (i = 0;i < 10;i++)\n{\nprintf("%c ", arr2[i]);\n}\nprintf("\\n");\n} \n \n \n \n', 'tags': '', 'url': '練習二.html'}, {'title': 'w11', 'text': '#include <stdio.h>\n#include <gd.h>\n#include <math.h>\n \nint main() {\n    int width = 800;\n    int height = 600;\n \n    gdImagePtr img = gdImageCreateTrueColor(width, height);\n    gdImageAlphaBlending(img, 0);\n \n    FILE *outputFile = fopen("hellogd.png", "wb");\n    if (outputFile == NULL) {\n \nfprintf(stderr, "Error opening the output file.\\n");\n \nreturn 1;\n    }\n \n    int red = gdImageColorAllocate(img, 255, 0, 0);\n    int blue = gdImageColorAllocate(img, 0, 0, 255);\n    int black = gdImageColorAllocate(img, 0, 0, 0);\n    int white = gdImageColorAllocate(img, 255, 255, 255);\n    // 長方形塗色\n    gdImageFilledRectangle(img, 0, 0, width, height, white);\n    gdImageFilledRectangle(img, 0, 0, (int)width/4, (int)height/4, blue);\n    // 橢圓形塗色\n    gdImageFilledEllipse(img, (int)width*3/4, (int)height/4, (int)width/4, (int)width/4, red);\n    // 橢圓形畫線\n    gdImageEllipse(img, (int)width*3/4, (int)height*3/4, (int)width/4, (int)width/4, red);\n    // 畫直線\n    gdImageLine(img, (int)width/2, (int)height/2, (int)width/2, (int)height/2 + 100, blue);\n \n    // 多邊形畫線\n    gdPoint points[4];\n    points[0].x = (int)width/4;\n    points[0].y = (int)height*3/4;\n    points[1].x = points[0].x + 100;\n    points[1].y = points[0].y;\n    points[2].x = points[1].x;\n    points[2].y = points[1].y + 100;\n    points[3].x = points[2].x - 100;\n    points[3].y = points[2].y;\n    gdImagePolygon(img, points, 4, black);\n \n    // 多邊形塗色\n    gdPoint points2[4];\n    points2[0].x = (int)width/3;\n    points2[0].y = (int)height/2;\n    points2[1].x = points2[0].x + 100;\n    points2[1].y = points2[0].y;\n    points2[2].x = points2[1].x;\n    points2[2].y = points2[1].y + 100;\n    points2[3].x = points2[2].x - 150;\n    points2[3].y = points2[2].y;\n    gdImageFilledPolygon(img, points2, 4, red);\n \n    gdImagePngEx(img, outputFile, 9);\n    fclose(outputFile);\n    gdImageDestroy(img);\n    return 0;\n} \n \n', 'tags': '', 'url': 'w11.html'}, {'title': 'w13', 'text': '// 包含標準輸出入程式庫的標頭文件\n#include <stdio.h>\n\n// 主函式\nint main() {\n    // Open a file to write displacement and velocity data\n    FILE *outputFile = fopen("motion_data.txt", "w");\n    if (!outputFile) {\n        fprintf(stderr, "Failed to create data file.\\n");\n        return 1;\n    }\n\n    // Simulate motion for 10 seconds and calculate displacement and velocity, while writing data to the file\n    double x = 0.2;  // Initial displacement\n    double v = 0.0;  // Initial velocity\n    double dt = 0.01; // Time step\n    double t = 0.0;  // Time\n\n    while (t <= 10.0) {\n        double acceleration = (-10.0 * x - 0.5 * v) / 1.0; // Modified system parameters here\n        v += acceleration * dt;\n        x += v * dt;\n\n        fprintf(outputFile, "%lf %lf %lf\\n", t, x, v);\n\n        t += dt;\n    }\n\n    // Close the data file\n    fclose(outputFile);\n\n    // Start a Gnuplot process using popen\n    FILE *gnuplotPipe = popen("gnuplot -persistent", "w");\n    if (!gnuplotPipe) {\n        fprintf(stderr, "Failed to start Gnuplot.\\n");\n        return 1;\n    }\n\n    // Use Gnuplot plotting commands, specify font and output as PNG\n    fprintf(gnuplotPipe, "set terminal pngcairo enhanced font \'default,10\' size 800,400\\n");\n    fprintf(gnuplotPipe, "set output \'./../images/motion_plot.png\'\\n");\n    fprintf(gnuplotPipe, "set title \'Displacement and Velocity vs. Time\'\\n");\n    fprintf(gnuplotPipe, "set xlabel \'Time (s)\'\\n");\n    fprintf(gnuplotPipe, "set ylabel \'Displacement (m)\'\\n");\n    fprintf(gnuplotPipe, "plot \'motion_data.txt\' using 1:2 with lines lw 2 title \'Displacement\', \\\n                             \'motion_data.txt\' using 1:3 with lines lw 2 title \'Velocity\'\\n");\n\n    // Close the Gnuplot process\n    fprintf(gnuplotPipe, "exit\\n");\n    pclose(gnuplotPipe);\n\n    return 0;\n} \n \n', 'tags': '', 'url': 'w13.html'}, {'title': 'w15', 'text': '#include <stdio.h>\n#include <gd.h>\n#include <math.h>\n \nvoid draw_exam_flag(gdImagePtr img);\nvoid draw_white_sun(gdImagePtr img, int center_x, int center_y, int sun_radius, int white, int red, int blue);\n \nint main() {\n    // width 3: height 2\n    int width = 1200;\n    int height = (int)(width*2.0 / 3.0);\n \n    gdImagePtr img = gdImageCreateTrueColor(width, height);\n    gdImageAlphaBlending(img, 0);\n \n    draw_exam_flag(img);\n \n    FILE *outputFile = fopen("./exam_flag.png", "wb");\n    if (outputFile == NULL) {\n        fprintf(stderr, "Error opening the output file.\\n");\n        return 1;\n    }\n    gdImagePngEx(img, outputFile, 9);\n    fclose(outputFile);\n    gdImageDestroy(img);\n    return 0;\n}\n \nvoid draw_exam_flag(gdImagePtr img) {\n    int width = gdImageSX(img);\n    int height = gdImageSY(img);\n    int red, white, blue;\n    int center_x = (int)(width/4);\n    int center_y = (int)(height/4);\n    int sun_radius = (int)(width/8);\n    int lineColor = gdImageColorAllocate(img, 255, 255, 255);\n \n  // 畫一條線\n    int x1 = 429;\n    int y1 = 125;\n    int x2 = 170;\n    int y2 = 274;\n \n    int x3 = 279;\n    int y3 = 165;\n    int x4 = 170;\n    int y4 = 274;\n \n    int x5 = 279;\n    int y5 = 165;\n    int x6 = 429;\n    int y6 = 125;\n   \n    // Colors for the flag\n    red = gdImageColorAllocate(img, 242, 0, 0); // Red color\n    white = gdImageColorAllocate(img, 255, 255, 255); // White stripes\n    blue = gdImageColorAllocate(img, 0, 41, 204); // Blue\n \n    // 繪製紅色矩形區域\n    gdImageFilledRectangle(img, 0, 0, width, height, red);\n \n    // 繪製藍色矩形區域\n    gdImageFilledRectangle(img, 0, 0, (int)(width/2.0), (int)(height/2.0), blue);\n \n    gdImageLine(img, x1, y1, x2, y2, lineColor);\n \n    gdImageLine(img, x3, y3, x4, y4, lineColor);\n \n    gdImageLine(img, x5, y5, x6, y6, lineColor);\n \n    return 0;\n} \n \n 尋找交點 \n #include <stdio.h>\n \n#include <gd.h>\n \n#include <math.h>\n \n \n \nvoid draw_roc_flag(gdImagePtr img);\n \nvoid draw_white_sun(gdImagePtr img, int x, int y, int size, int color);\n \n \n \nint main() {\n \n    // width 3: height 2\n \n    int width = 1200;\n \n    // 國旗長寬比為 3:2\n \n    int height = (int)(width*2.0 / 3.0);\n \n \n \n    gdImagePtr img = gdImageCreateTrueColor(width, height);\n \n    gdImageAlphaBlending(img, 0);\n \n \n \n    draw_roc_flag(img);\n \n \n \n    FILE *outputFile = fopen("roc_flag_in_gd.png", "wb");\n \n    if (outputFile == NULL) {\n \n        fprintf(stderr, "Error opening the output file.\\n");\n \n        return 1;\n \n    }\n \n    gdImagePngEx(img, outputFile, 9);\n \n    fclose(outputFile);\n \n    gdImageDestroy(img);\n \n    return 0;\n \n}\n \n \n \nvoid draw_roc_flag(gdImagePtr img) {\n \n    int width = gdImageSX(img);\n \n    int height = gdImageSY(img);\n \n    int red, white, blue;\n \n    // 白日位於青天面積正中央, 因此中心點座標為長寬各 1/4 處\n \n    int center_x = (int)(width/4);\n \n    int center_y = (int)(height/4);\n \n    // gdImageFilledEllipse 需以長寬方向的 diameter 作圖\n \n    // 由於中央白日圓形的半徑為青天寬度的 1/8\n \n    // 因此中央白日圓形的直徑為青天寬度的 1/4, 也就是國旗寬度的 1/8\n \n    // 而且白日十二道光芒的外圍圓形其半徑也是國旗寬度的1/8\n \n    int sun_radius = (int)(width/8);\n \n    // 中央白日圓形的直徑等於十二道光芒外圍圓形的半徑\n \n    int white_circle_dia = sun_radius;\n \n    // 中央藍色圓形半徑為中央白日的 1又 2/15\n \n    int blue_circle_dia = white_circle_dia +  white_circle_dia*2/15;\n \n    // 根據 https://www.moi.gov.tw/cp.aspx?n=10621 訂定國旗三種顏色值\n \n    red = gdImageColorAllocate(img, 255, 0, 0); // 紅色\n \n    white = gdImageColorAllocate(img, 255, 255, 255); // 白色\n \n    blue = gdImageColorAllocate(img, 0, 0, 149); // 藍色\n \n    // 根據畫布大小塗上紅色長方形區域\n \n    gdImageFilledRectangle(img, 0, 0, width, height, red);\n \n    // 青天面積為整面國旗的 1/4, 也是採用長方形塗色\n \n    gdImageFilledRectangle(img, 0, 0, (int)(width/2.0), (int)(height/2.0), blue);\n \n  {int x1 = 429;\n \n   int y1 = 125;\n \n   int x2 = 279;\n \n   int y2 = 165;\n \n \n \n   // 畫一條線連接兩個點\n \n   gdImageLine(img, x1, y1, x2, y2, white);\n \n  }\n \n  {int x1 = 170;\n \n     int y1 = 274;\n \n     int x2 = 279;\n \n     int y2 = 165;\n \n \n \n     // 畫一條線連接兩個點\n \n     gdImageLine(img, x1, y1, x2, y2, white);\n \n  }\n \n  {\n \n    int x1 = 170;\n \n     int y1 = 274;\n \n     int x2 = 429;\n \n     int y2 = 125;\n \n \n \n     // 畫一條線連接兩個點\n \n     gdImageLine(img, x1, y1, x2, y2, white);\n \n  }\n \n  // 利用一個藍色大圓與白色小圓畫出藍色環狀\n \n  gdImageFilledEllipse(img, center_x, center_y, blue_circle_dia, blue_circle_dia, blue);\n \n  gdImageFilledEllipse(img, center_x, center_y, white_circle_dia, white_circle_dia, white);\n \n  \n \n \n \n  // 定義座標結構\n \n  typedef struct {\n \n      double x;\n \n      double y;\n \n  } Point;\n \n \n \n  // 計算圓與線的交點\n \n  void circleLineIntersection(double h, double k, double r, double x1, double y1, double x2, double y2) {\n \n      // 直線斜率\n \n      double m = (y2 - y1) / (x2 - x1);\n \n \n \n      // 直線方程式中的常數項\n \n      double b = y1 - m * x1;\n \n \n \n      // 圓與直線交點的計算\n \n      double A = 1 + pow(m, 2);\n \n      double B = 2 * (m * b - m * k - h);\n \n      double C = pow(k, 2) - pow(r, 2) + pow(h, 2) - 2 * b * k + pow(b, 2);\n \n \n \n      // 判斷交點個數\n \n    double discriminant = pow(B, 2) - 4 * A * C;\n \n    if (discriminant > 0) {\n \n        double x_intersect1 = (-B + sqrt(discriminant)) / (2 * A);\n \n        double y_intersect1 = m * x_intersect1 + b;\n \n        printf("交點: (%.2f, %.2f)\\n", x_intersect1, y_intersect1);\n \n \n \n        double x_intersect2 = (-B - sqrt(discriminant)) / (2 * A);\n \n        double y_intersect2 = m * x_intersect2 + b;\n \n        printf("交點: (%.2f, %.2f)\\n", x_intersect2, y_intersect2);\n \n    } else if (discriminant == 0) {\n \n        double x_intersect = -B / (2 * A);\n \n        double y_intersect = m * x_intersect + b;\n \n        printf("交點: (%.2f, %.2f)\\n", x_intersect, y_intersect);\n \n    } else {\n \n        printf("No points.\\n");\n \n    }\n \n \n \n  }\n \n \n \n \n \n      // 圓的參數\n \n      double circle_x = (int)(width/4); // 圓心 x 座標\n \n      double circle_y = (int)(height/4); // 圓心 y 座標\n \n      double radius = white_circle_dia +  white_circle_dia*2/15;   // 圓半徑\n \n   \n \n      // 兩點座標\n \n       \n \n \n \n   \n \n  double x3 = 170;\n \n  double y3 = 274;\n \n  double x4 = 279;\n \n  double y4 = 165;\n \n \n \n  circleLineIntersection(circle_x, circle_y, radius, x4, y4, x3, y3);\n \n   \n \n     \n \n  double x5 = 279;\n \n  double y5 = 165;\n \n  double x6 = 429;\n \n  double y6 = 125;\n \n \n \n  circleLineIntersection(circle_x, circle_y, radius, x6, y6, x5, y5);\n \n   \n \n \n \n   \n \n   \n \n   \n \n   \n \n  } \n \n \n \n', 'tags': '', 'url': 'w15.html'}, {'title': 'w16', 'text': '#include <gd.h>\n#include <stdio.h>\n#include <math.h>\n \n#define WIDTH 800\n#define HEIGHT 600\n#define SCALE 100\n \n//繪製電阻形狀\nvoid drawResistor(gdImagePtr im, int x1, int y, int width, int height) {\n    int startX = x1 ;\n    int endX = x1 + width ;\n \n    // 第一段直線向前走一段\n    gdImageLine(im, startX, y, startX + width / 4 , y, gdImageColorAllocate(im, 0, 0, 255));\n \n    // 向上45度\n    gdImageLine(im, startX + width / 4 , y, startX + width / 4 + height / 2 , y - height / 2, gdImageColorAllocate(im, 0, 0, 255));\n \n    // 向下90度\n    gdImageLine(im, startX + width / 4 + height / 2, y - height / 2 , startX + width / 4 + height / 2 + height , y + height / 2, gdImageColorAllocate(im, 0, 0, 255));\n \n    // 向上90度\n    gdImageLine(im, startX + width / 4 + height / 2 + height, y + height / 2, startX + width / 4 + height / 2 + 2 * height, y - height / 2, gdImageColorAllocate(im, 0, 0, 255));\n \n    // 向下90度\n    gdImageLine(im, startX + width / 4 + height / 2 + 2 * height , y - height / 2, startX + width / 4 + height / 2 + 3 * height , y + height / 2, gdImageColorAllocate(im, 0, 0, 255));\n \n    // 向上90度\n    gdImageLine(im, startX + width / 4 + height / 2 + 3 * height, y + height / 2 , startX + width / 4 + height / 2 + 4 * height, y - height / 2, gdImageColorAllocate(im, 0, 0, 255));\n \n    // 向下90度\n    gdImageLine(im, startX + width / 4 + height / 2 + 4 * height, y - height / 2, startX + width / 4 + height / 2 + 5 * height, y + height / 2, gdImageColorAllocate(im, 0, 0, 255));\n \n  // 向上45度\n    gdImageLine(im, startX + width / 4 + height / 2 + 5 * height, y + height / 2, startX + width / 4 + height / 2 + 5 * height + height / 2, y, gdImageColorAllocate(im, 0, 0, 255));\n \n  gdImageLine(im, startX + width / 4 + height / 2 + 5 * height + height / 2, y, startX + width / 4 + height / 2 + 5 * height + height / 2 +5 , y, gdImageColorAllocate(im, 0, 0, 255));\n \n \n  {\n    int startX = 100;\n  gdImageColorAllocate(im, 0, 0, 255);\n \n \n    // 第一段直線向前走一段\n    gdImageLine(im, startX, y, startX + width / 4 , y, gdImageColorAllocate(im, 0, 0, 255));\n \n    // 向上45度\n    gdImageLine(im, startX + width / 4 , y, startX + width / 4 + height / 2 , y - height / 2, gdImageColorAllocate(im, 0, 0, 255));\n \n    // 向下90度\n    gdImageLine(im, startX + width / 4 + height / 2, y - height / 2 , startX + width / 4 + height / 2 + height , y + height / 2, gdImageColorAllocate(im, 0, 0, 255));\n \n    // 向上90度\n    gdImageLine(im, startX + width / 4 + height / 2 + height, y + height / 2, startX + width / 4 + height / 2 + 2 * height, y - height / 2, gdImageColorAllocate(im, 0, 0, 255));\n \n    // 向下90度\n    gdImageLine(im, startX + width / 4 + height / 2 + 2 * height , y - height / 2, startX + width / 4 + height / 2 + 3 * height , y + height / 2, gdImageColorAllocate(im, 0, 0, 255));\n \n    // 向上45度\n      gdImageLine(im, startX + width / 4 + height / 2 + 3 * height, y + height / 2, startX + width / 4 + height / 2 + 3 * height + height / 2, y, gdImageColorAllocate(im, 0, 0, 255));\n \n    gdImageLine(im, startX + width / 4 + height / 2 + 3 * height + height / 2, y, startX + width / 4 + height / 2 + 3 * height + height / 2 +5 , y, gdImageColorAllocate(im, 0, 0, 255));\n }\n \n  {\n    int startX = 585;\n  gdImageColorAllocate(im, 0, 0, 255);\n \n \n    // 第一段直線向前走一段\n    gdImageLine(im, startX, y, startX + width / 4 , y, gdImageColorAllocate(im, 0, 0, 255));\n \n    // 向上45度\n    gdImageLine(im, startX + width / 4 , y, startX + width / 4 + height / 2 , y - height / 2, gdImageColorAllocate(im, 0, 0, 255));\n \n    // 向下90度\n    gdImageLine(im, startX + width / 4 + height / 2, y - height / 2 , startX + width / 4 + height / 2 + height , y + height / 2, gdImageColorAllocate(im, 0, 0, 255));\n \n    // 向上90度\n    gdImageLine(im, startX + width / 4 + height / 2 + height, y + height / 2, startX + width / 4 + height / 2 + 2 * height, y - height / 2, gdImageColorAllocate(im, 0, 0, 255));\n    // 向下90度\n    gdImageLine(im, startX + width / 4 + height / 2 + 2 * height , y - height / 2, startX + width / 4 + height / 2 + 3 * height , y + height / 2, gdImageColorAllocate(im, 0, 0, 255));\n \n    // 向上45度\n      gdImageLine(im, startX + width / 4 + height / 2 + 3 * height, y + height / 2, startX + width / 4 + height / 2 + 3 * height + height / 2, y, gdImageColorAllocate(im, 0, 0, 255));\n \n    gdImageLine(im, startX + width / 4 + height / 2 + 3 * height + height / 2, y, startX + width / 4 + height / 2 + 3 * height + height / 2 +5 , y, gdImageColorAllocate(im, 0, 0, 255));\n \n    gdImageLine(im, 100, y +20, 700, y +20, gdImageColorAllocate(im, 0, 255, 0));\n \n}\n}\n \nint main() {\n    gdImagePtr im;\n    FILE *outputFile;\n \n    // 創建圖像物件\n    im = gdImageCreateTrueColor(WIDTH, HEIGHT);\n    if (im == NULL) {\n        fprintf(stderr, "Error creating GD image.\\n");\n        return 1;\n    }\n \n    outputFile = fopen("1.png", "wb");\n    if (outputFile == NULL) {\n        fprintf(stderr, "Error opening the output file.\\n");\n        return 1;\n    }\n \n    //配置顏色\n    int black, white, red, blue, green;\n \n    black = gdImageColorAllocate(im, 0, 0, 0);\n    white = gdImageColorAllocate(im, 255, 255, 255);\n    red = gdImageColorAllocate(im, 255, 0, 0);\n    blue = gdImageColorAllocate(im, 0, 0, 255);\ngreen = gdImageColorAllocate(im, 0, 255, 0);\n    gdImageFilledRectangle(im, 0, 0, WIDTH - 1, HEIGHT - 1, white);\n \n    // 繪製牆面\n    gdImageLine(im, SCALE, SCALE, SCALE, HEIGHT - SCALE, black);\n    gdImageLine(im, WIDTH - SCALE, SCALE, WIDTH - SCALE, HEIGHT - SCALE, black);\n \n   // 繪製彈簧(電阻)\n    drawResistor(im, WIDTH / 3 + SCALE / 2, HEIGHT / 2, SCALE / 2, SCALE / 4);\n \n    // 繪製質量（方形）\n    gdImageFilledRectangle(im, WIDTH / 3 - SCALE / 2, HEIGHT / 2 - SCALE / 2, WIDTH / 3 + SCALE / 2, HEIGHT / 2 + SCALE / 2, red);\n    gdImageFilledRectangle(im, WIDTH * 2 / 3 - SCALE / 2, HEIGHT / 2 - SCALE / 2, WIDTH * 2 / 3 + SCALE / 2, HEIGHT / 2 + SCALE / 2, red);\n \n  gdImageFilledRectangle(im, 100, HEIGHT +300, 700, HEIGHT /2 +49 , black);\n \n \n    //生成圖片\n    gdImagePng(im, outputFile);\n    fclose(outputFile);\n    gdImageDestroy(im);\n \n    return 0;\n} \n \n #include <stdio.h>\n \nint main() {\n    FILE *gnuplotPipe = popen("gnuplot", "w");\n    if (gnuplotPipe) {\n        fprintf(gnuplotPipe, "set terminal png\\n");\n        fprintf(gnuplotPipe, "set output \'motion_plot.png\'\\n");\n        fprintf(gnuplotPipe, "set xlabel \'Time\'\\n");\n        fprintf(gnuplotPipe, "set ylabel \'Position / Velocity\'\\n");\n        fprintf(gnuplotPipe, "plot \'motion_data.txt\' using 1:2 with lines title \'m1 position\', \'motion_data.txt\' using 1:3 with lines title \'m2 position\', \'motion_data.txt\' using 1:4 with lines title \'m1 velocity\', \'motion_data.txt\' using 1:5 with lines title \'m2 velocity\'\\n");\n        fprintf(gnuplotPipe, "exit\\n");\n        fflush(gnuplotPipe);\n        pclose(gnuplotPipe);\n    } else {\n        printf("Error opening pipe to Gnuplot.\\n");\n    }\n    return 0;\n}\n \n Brython \n https://en.wikipedia.org/wiki/Python_(programming_language) \n Examples: \n https://gist.github.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d \n https://www.geeksforgeeks.org/python-programming-examples/ \n https://www.programiz.com/python-programming/examples \n https://www.freecodecamp.org/news/python-code-examples-sample-script-coding-tutorial-for-beginners/ \n Python Tutorial: \n https://docs.python.org/3/tutorial/ \n An informal introduction to Python \n Indentation (Python 採 4 個 Spaces 縮排, 以界定執行範圍) \n Variables ( Python Keywords ) \n Comments (# 單行註解, 三個單引號或三個雙引號標註多行註解) \n Numbers  (整數 int(), 浮點數 float()) \n Strings  (字串) \n print (Python 內建函式,  print()  函式) \n Python control flow tools \n for \n if \n range \n open \n read \n lists \n tuples \n dictionaries \n functions \n try ... except \n break \n pass \n classes \n 這個頁面 demo 如何在同一頁面下納入多個線上 Ace 編輯器與執行按鈕 ( practice_html.txt  動態頁面超文件). \n practice_html.txt  動態頁面超文件應該可以在啟動 Brython 時, 設定將 .py 檔案放入 downloads/py 目錄中引用. \n 亦即將所有對應的 html 也使用 Brython 產生, 然後寫為  class  後, 在範例導入時透過  instance  引用. \n <!-- 啟動 Brython -->\n<script>\nwindow.onload=function(){\nbrython({debug:1, pythonpath:[\'./../cmsimde/static/\',\'./../downloads/py/\']});\n}\n</script> \n 從 1 累加到 100: \n 1 add to 100 \n 將 iterable 與 iterator  相關說明 , 利用 Brython 與 Ace Editor 整理在這個頁面. \n  導入 brython 程式庫  \n \n \n \n \n  啟動 Brython  \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n \n \n \n  add 1 to 100 開始  \n \n \n  add 1 to 100 結束 \n  editor1 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor1 結束   ##########################################  \n 從 1 累加到 100 part2: \n 1 add to 100 cango_three_gears BSnake AI Tetris Rotating Block \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  add 1 to 100 part2 開始  \n \n \n  add 1 to 100 part2 結束 \n  editor2 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor2 結束  \n \n \n \n', 'tags': '', 'url': 'w16.html'}]};